<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tutorial UML - Domingo Esteban</title>
  <meta name="keywords" content="Domingo, Esteban, Cabala, Robotics, Peru, Spain, Madrid, Arequipa, Unified, Modelling, Language, UML">
  <meta name="description" content="Tutorial UML- Domingo Esteban">
  <meta name="author" content="Domingo Esteban">

  <!-- Mobile viewport optimized -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <!--meta name="viewport" content="width=device-width, initial-scale=1"-->

  <!-- Bootstrap CSS -->
  <!-- <link rel="stylesheet" href="../framework/css/bootstrap.css"> -->
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet'/>
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css' rel='stylesheet'/>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../includes/css/styles.css"/>
  <link rel="stylesheet" href="../../includes/css/tutorials-styles.css"/>

  <!-- Including Modernizr (Before any other Javascript) -->

  <!-- Favicon -->
  <link href="../../images/icons/robot-favicon.ico" rel="icon" type="image/x-icon" />

</head>

<body>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h1 align="center">UML</h1>

    <ul>
    <li><a href="#introduccion">Introducción</a></li>
    <li><a href="#diagramas_estructura_estatica">Diagramas de estructura estática</a></li>
    <li><a href="#diagramas_caso_uso">Diagramas de casos de uso</a></li>
    <li><a href="#diagramas_interaccion">Diagramas de interacción</a></li>
    <li><a href="#diagramas_estado_actividades">Diagramas de estado y actividades</a></li>
    <li><a href="#modelado_fisico">Modelado físico de un sistema</a></li>
    <li><a href="#uml_2">UML 2.0</a></li>
    </ul>
    <article>
    
    <h1 id="introduccion">Introducción</h1>
    
    <p>
      UML (Unified Modelling Language) consiste en un lenguaje que permite documentar, modelar y establecer cualquiera de los elementos que conforman un sistema orientado a objetos.
    </p>

    <p>
      Antes de la existencia de UML, existían distintos métodos y técnicas de orientación a objetos, enfoques variados, muchos problemas de aprendizaje y uso de herramientas, y se carecía de estándares únicos.
    </p>

    <p>
      Combina las metodologías de orientación a objetos de Booch, Rumbaugh y Jacobson.
    </p>

    <p>
      En enero de 1997, se crea la primera versión adoptada como un estándar por el OMG (Object Management Group). Posteriormente, se desarrollaron diversas versiones, y en la actualidad se sigue revisando el estándar.
    </p>
    
    <p>
      Según el <a href="http://www.omg.org">OMG</a>: <b>Unified Modelling Language</b> (<b>UML</b>) es un lenguaje para específicar, visualizar, construir y documentar los elementos de los sistemas software, así como los modelos de negocio y otros sistemas no software.
    </p>

    <p>
      UML cubre las áreas principales que existen a la hora de crear una aplicación orientada a objetos, porque aglutina los principales enfoques de orientación a objetos.
    </p>

    <p>
      Un problema de UML es su falta de integración con otras técnicas como los patrones de diseño o las interfaces de usuario.
      Además, es importante destacar que UML es un lenguaje y no una metodología, por lo que necesita de un proceso de desarrollo, como puede ser <b>RUP</b> (<b>Rational Unified Process</b>) que combina los diagramas de UML con una serie de fases para su realización de un desarrollo software.
    </p>

    <p>
      El éxito de UML, y su aceptación por un amplio procentaje de la industria, se debe a tres motivos principales:
    </p>
      <ul>
        <li>El prestigio de sus tres creadores (Rumbaugh, Jacobson y Booch)</li>
        <li>La lista de potentes empresas que han respaldado UML desde sus inicios.</li>
        <li>La incorpación en un único modelo de las principales ventajas de tres metodologías: OMT, Booch y OOSE.</li>
      </ul>

      <h2>Metodologías orientadas a objetos</h2>

      <p>
        Dentro del campo de la Ingeniería de Software, una metodología está relacionado con un proceso lógico y ordenado que permite producir un programa o software informático.
      </p>

      <p>
        Cada metodología incluye sus propias reglas, técnicas y notaciones predefinidas. Por lo general aportan un algoritmo (conjunto de pasos ordenados) que debe completarse de forma secuencial para conseguir los objetivos. Los ciclos de vida marcan esta secuencialidad.
      </p>

      <p>
        Dentro de los diversos paradigmas del mundo de la informática, el paradigma orientado a objetos consiste en una serie de normas para abordar los problemas. Su base es el mundo real y el concepto es el objeto, que combina estructura de datos y comportamiento en una sola entidad.
      </p>

      <h3>Object Modelling Technique</h3>
        <p>
          OMT o Técnica de Modelado de Objetos consiste en una metodología de Ingeniería de Software para el desarrollo de aplicaciones tomando como paradigma de partida la orientación a objetos. James Rumbaugh es uno de sus autores principales y destacan tres modelos:
        </p>
          <ul>
            <li><b>Modelo de objetos</b>: Contempla aspectos estáticos y proporciona información sobre la estructura de los objetos. Especifíca <i>"a qué le sucede"</i>. Consiste en un diagrama de objetos más un diccionario de datos. El diagrama de objetos muestra las clases y sus relaciones (generalización, agregación, asociación e instancia), mientras que el diccionario de datos representa el detalle de las clases en el diagrama de objetos.</li>
            <li><b>Modelo dinámico</b>: Conjunto de diagramas de estado más un diagrama de flujo de eventos global. Especifíca <i>"cuándo sucede"</i>.</li>
            <li><b>Modelo funcional</b>: Es un diagrama de flujo con restricciones. Especifíca <i>"lo que sucede"</i></li>
          </ul>

        <p>
          Dentro de esta metodología existen tres fases:
        </p>
          <ul>
            <li><b>Análisis</b>: En esta fase se obtiene un modelo preciso, conciso, comprensivo y correcto del mundo real; es decir, se comprende el sistema, se elabora un modelo de resolución y se determina el dominio. En esta fase se obtiene la captura de requisitos. La fase está marcada por tres aspectos: los objetos y sus relaciones, el flujo dinámico de control y las transformaciones funcionales.</li>
            <li><b>Diseño del sistema</b>: Pretende mostrar la arquitectura del sistema: división del sistema en subsistemas, concurrencia, comunicación de subsistemas y almacenamiento de datos.</li>
            <li><b>Diseño de objetos</b>: Pretende refinar y detallar el modelo de análisis, de forma que se pueda construir un modelo que sea cercano a la máquina. El resultado final de esta fase es el documento de diseño, el cual contiene versiones más detalladas de los modelos construidos en el análisis.</li>
          </ul>

      <h3>Object Oriented Design Booch</h3>
        <p>
          El método Booch destaca por sus diagramas, que se utilizan para describir las decisiones de análisis y diseño durante la creación de un sistema orientado a objetos.
        </p>

        <ul>
          <li><b>Diagrama de Clases:</b> Consisten en un conjunto de clases y relaciones entre ellas. Puede contener clases, utilidades, clases paramétricas y metaclases. Los tipos de relaciones son asociaciones, herencia, instancia, contenencia, uso y metaclase.</li>
          <li><b>Especificación de Clases:</b> Usado para capturar toda la información importante acerca de una clase en formato texto.</li>
          <li><b>Diagrama de Categorías:</b> Clases agrupadas de forma lógica bajo diversas categorías.</li>
          <li><b>Diagrama de Transición de Estados:</b> Muestra el comportamiento dinámico del sistema.</li>
          <li><b>Diagrama de Objetos:</b> Muestra objetos en el sistema y su relación lógica. Pueden ser diagramas de escenario, en los cuales se manifiesta la colaboración entre objetos, o diagramas de instancia, que muestran la existencia de los objetos y sus relaciones estructurales entre ellos.</li>
          <li><b>Diagrama de Tiempo:</b> Aumenta el diagrama de objetos con información acerca de eventos externos y tiempod e llegada de los mensajes.</li>
          <li><b>Diagrama de Módulos:</b> Muestra la localización de objetos y clases en los módulos del diseño físico de un sistema. Representa parte o la totalidad de la arquitectura de módulos del sistema.</li>
          <li><b>Subsistemas:</b> Un subsistema es una agrupación de módulos. Es útil en modelos de gran escala.</li>
          <li><b>Diagrama de Procesos:</b> Muestra la localización de los procesos en los distintos procesos de un ambiente distribuido.</li>
        </ul>

        <p>
          Dentro de esta metodología se encuentran tres fases:
        </p>
          <ul>
            <li><b>Análisis de requerimientos</b>: Involucra las funciones primarias del sistema: principales entradas y salidas del sistema, referencias a políticas, sistemas existentes o procedimientos, etc. Además de los mecanismos claves que el sistema debe proveer: estado de entrada, estado de salida y estados esperados.</li>
            <li><b>Análisis de dominio</b>.</li>
            <li><b>Diseño</b>.</li>
          </ul>

      <h2>Ciclo de vida de un sistema</h2>
      <p>
        El ciclo de vida propone un patrón con una serie de pasos y la optimización del resultado final. Adicionalmente, el ciclo de vida indica la forma y la estructuración de los pasos que se dan para realizar un determinado desarrollo software. Estos tres pasos son:
        <ul>
          <li>Análisis. <i>¿Qué se hace?</i></li>
          <li>Diseño. <i>¿Cómo se hace?</i></li>
          <li>Implementación. <i>Programar el sistema</i></li>
        </ul>
      </p>

      <h3>Ciclo de vida en cascada</h3>
        <p>
          El <b>ciclo de vida en cascada</b> es apto para problemas con requisitos bien definidos. Requiere de experiencia en el grupo de desarrollo y conocimientos del entorno y herramientas.
        </p>

        <p>
          Se caracteriza porque cada una de las etapas lleva a otra. Y pueden ser:
        </p>
          <ul>
            <li><b>Ciclo de vida en Cascada Tradicional:</b> Cada etapa necesita finalizarse para pasar a la siguiente. Nunca se vuelve hacia atrás.</li>

            <img src="../../images/tutorials/uml/ciclo_de_vida_cascada.jpg" height="306" width="212" alt="">

            <li><b>Ciclo de vida en Cascada con Mejora Iterativa:</b> A diferencia de la cascada tradicional, es posible una realimentación para revisar la etapa anterior.</li>

            <img src="../../images/tutorials/uml/ciclo_de_vida_cascada_mejora_iterativa.jpg" height="306" width="254" alt="">

          </ul>

      <h3>Ciclo de vida Prototipado</h3>
        <p>
          Se construye un prototipo que sirva como referencia para validad el producto. Existen dos tipos:
        </p>
        <ul>
          <li><b>Desechable:</b> El prototipo se crea a partir de las partes peor definidas y se desecha una vez cumple su función. Es apto cuando la definición del problema no es clara y es poco volátil.</li>

          <img src=".." height="306" width="254" alt="$$$Imagen Ciclo de vida prototipado$$$">

          <li><b>Evolutivo:</b> Apto para problemas mal definidos. Se utiliza un sistema experto en el cual los conocimientos van surgiendo y las necesidades se van incorporando. Reduce el riesgo y aumenta la probabilidad de éxito. Se obtienen versiones rápidas del sistema y el ejemplo más concreto lo constituyen las interfaces de usuario.</li>
        </ul>

      <h3>Ciclo de vida Incremental</h3>

      <p>
        Este ciclo es apto para problemas medianamente definidos. Suele utilizarse en grandes proyectos.
      </p>
      <p>
        Se realiza un ciclo completo (análisis, diseño e implementación), se presenta una versión y con los comentarios obtenidos se realiza un nuevo ciclo para dar una segunda versión.
      </p>

      <img src=".." height="306" width="254" alt="$$$Imagen Ciclo de vida Incremental$$$">


      <h2>Principales Diagramas</h2>

      <p>
        UML propone diferentes diagramas para cubrir gran parte de las áreas de un proceso informático; sin embargo, algunos diagramas no pueden clasificarse de forma concreta dentro del análisis o dentro del diseño ya que seuelen ser versátiles y pueden trabajar en distintas fases.
      </p>

      <p>
        Un <b>diagrama</b> es una perspectiva concreta de una parte de un sistema y su respectiva funcionalidad. Describe lo que hace un sistema pero no cómo se va a implementar.
      </p>

      <p>
        Los principales diagramas existentes son:
      </p>
      <ul>
        <li>Diagrama de Estructura Estática: engloba el Modelo Conceptual y el Diagrama de Clases.</li>
        <li>Diagrama de Objetos</li>
        <li>Diagrama de Casos de Uso</li>
        <li>Diagrama de Interacción: engloba el Diagrama de Secuencia y el Diagrama de Colaboración.</li>
        <li>Diagrama de Estados</li>
        <li>Diagrama de Componentes</li>
        <li>Diagrama de Distribución</li>
        <li>Diagrama de Actividad</li>
      </ul>

      <p>
        En la versión 2.0, se han diseñado nuevos diagramas como por ejemplo el Diagrama de Tiempos. Así mismo, el Diagrama de Colaboraciones pasó a llamarse Diagrama de Comunicaciones.
      </p>

      <h2>Ejemplo UML</h2>

      <ul>
        <li><b>Detalles:</b></li>
        <ul>
          <li>Nombre del Juego: Dardos</li>
          <li>Objetivos: Conseguir más puntos que el rival</li>
          <li>Desarrollo:</li>
          <ul>
            <li>Cada jugador dispondrá de tres dardos y otras tantas tiradas.</li>
            <li>El jugador lanzará los 3 dardos de forma consecutiva contra la diana.</li>
            <li>La zona de impacto proporcionará una puntuación.</li>
            <li>El resultado será la media de los tres lanzamientos</li>
            <li>Hay que prever que alguno de los dardos pueda disponer de algún modificador (por ejemplo el segundo dardo vale el doble)</li>
          </ul>
        </ul>
        <li><b>Diagrama de Casos de Uso:</b></li>
        <ul>
          <li>Este diagrama es una descripción textual (y aveces gráfica) de las distintas acciones que el sistema va a realizar. Constituye una fase muy importante del análisis porque permite pasar de los requisitos que debe cumplir el sistema a una definición más formalizada y concreta de lo que realmente quiere hacerse.</li>
          <li>En el ejemplo, la única acción importante es lanzar el dardo (3 dardos concretamente)</li>
          <li>
            <img src=".." height="306" width="254" alt="$$$Imagen Caso de Uso Dardos$$$">
          </li>
        </ul> 
        <li><b>Modelo Conceptual:</b></li>
        <ul>
          <li>Con este modelo se intenta descubir los conceptos principales, los atributos de los que dispone cada uno y cómo se relacionan entre sí.</li>
          <li>El modelo conceptual es una estructura estática, y modela los elementos del dominio.</li>
          <li>No es una descripción de los objetos del software</li>
          <li>En el ejemplo, el modelo conceptual sería:</li>
          <li>
            <img src=".." height="306" width="254" alt="$$$Imagen Modelo Conceptual Dardos$$$">
          </li>
          <li>Los conceptos importantes son: Jugador, Dardo y Diana.</li>
          <li>Las relaciones entre los conceptos son:</li>
          <ul>
            <li>El Jugador lanza el Dardo.</li>
            <li>El Jugador juega a la Diana.</li>
            <li>El Dardo impacta contra la Diana.</li>
          </ul>
          <li>Los atributos o características de los conceptos son:</li>
          <ul>
            <li>El Jugador tiene como rasgo principal su identificación (nombre).</li>
            <li>La Diana tiene valores (puntuaciones).</li>
            <li>Cada Dardo tiene un orden ya que el enunciado comenta que el orden puede influir en la puntuación.</li>
          </ul>
        </ul>
        <li><b>Diagrama de Secuencia:</b></li>
        <ul>
          <li>En el grupo de Diagramas de Interacción se encunetran los Diagramas de Secuencia. Este diagrama proporciona un gráfico con la secuencia ordenada de los pasos dados y eventos.</li>  
          <li>El diagrama emplea unas líneas verticales para indicar el origen del mensaje (el evento ocurrido) y el destino.</li>
          <li>Debe ser parecdo a un caso real. Si se leen de arriba a abajo los disntinos eventos que figuran encima de cada línea horizontal, se descubre una lectura detallada de todo el proceso.</li>
          <li>En el ejemplo:</li>
          <ul>
            <li>Mediante el mensaje Jugar se inicia el juego.</li>
            <li>Desde la Diana se envía el mensaje Lanzar() al dardo d1.</li>
            <li>El dardo d1 responde a la Diana con el mensaje Impactar().</li>
            <li>Para calcular el valor, la Diana envía el menasje Dar_Valor al área (se asume una simulación de las áreas existentes en las dianas reales). En ese mensaje se incluye la posición de impacto del dardo mediante las coordenadas PosX y PosY.</li>
            <li>Este proceso se repite para los tres dardos.</li>
            <li>Este proceso se repite para los tres dardos</li>
          </ul>
          <li>Se están obviando otras funcionalidades (suma de los tres dardos, puntación acumulada, etc.)</li>
        </ul>
        <li><b>Diagrama de Clases:</b></li>
        <ul>
          <li>Describe las clases y elementos del sistema. Es un complemento indispensable de los diagramas de itneracción. Cualquier pieza que aparezca en el Diagrama de Secuencia debe aparecer en el Diagrama de Clases.</li>
          <li>Este diagrama presenta elementos de la solución software. Al realizarse en la fase de Diseño es un modelo válido para que el programador pueda implementarlo.</li>
          <li>A diferencia del Modelo Conceptual, no se presentan objetos del mundo real. El diagrama presenta elementos informáticos. Se trabaja con clases.</li>
          <li>Para el ejemplo: </li>
          <ul>
            <li>Existe un mensaje Lanzar desde el objeto Diana a cada Dardo. Significa que la clase Dardo incluye ese método.</li>
            <li>Existe un mensaje Impactar desde cada objeto Dardo a cada Diana. Significa que la clase Diana incluye ese método.</li>
            <li>Existe un mensaje Dar_Valor desde el objeto Diana al objeto área. Significa que la clase Áreas incluye ese método.</li>
            <li>Además, se incluyen una serie de atributos (características) dentro de cada clase en base a los parámetros empleados.</li>
            <li>
              <img src=".." height="306" width="254" alt="$$$Imagen Diagrama de Clases Dardos$$$">
            </li>
          </ul>
        </ul>

      </ul>
    </article>

    <article>
    <h1 id="diagramas_estructura_estatica">Diagramas de Estructura Estática</h1>
    <h2>Introducción</h2>
      <p>
        Se engloba dos tipos de diagramas:
      </p>
      <ul>
        <li>Modelo Conceptual: Utilizado en fase de análisis, modela los elementos del dominio.</li>
        <li>Diagrama de Clases: Utilizado en fase de diseño, queda ligado a la solución software y emplea elementos del lenguaje de programación.</li>
      </ul>
      <p>
        Conceptualmente, estos diagramas son distintos pero ambos comparten una notación parecida en los elementos que conforman el sistema, es decir, las clases, los objetos y las relaciones existentes entre ellos.
      </p>

    <h2>Modelo conceptual</h2>
      <p>
        El <b>Modelo conceptual</b> es un diagrama que representa un modelo de los elementos del dominio.
      </p>
      <p>
        Una parte importante para delimitar el dominio del problema es la identificación y posterior tratamientos de los conceptos que lo conforman. Estos conceptos representan elementos del mundo real, no componentes software.
      </p>
      <p>
        Su objetivo es el aumento de la comprensión del problema existente. Por este motivo es interesante buscar el mayor número posible de conceptos.
      </p>

      <h3>Fase I: Identificar los conceptos</h3>
      <p>
        A partir del documento de requisitos y el conocimiento que se tiene del dominio del problema, se identifican los conceptos.
      </p>
      <p>
        Estos conceptos aparecen por medio de la revisión de las categorías relacionadas con el problema (objetos físicos, organizaciones, eventos, transacciones, lugares, etc.) o bien de la lista de sustantivos hallados en los documentos de requisitos.s
      </p>
      <p>
        Entre los tipos de conceptos que se pueden utilizar se encuentran: conceptos abstractos, transacciones, documentación, lugares, protocolos, políticas, reglas, libros, catálogos, roles, especificaciones, organizaciones, archivos, descripciones, otros sistemas, etc.
      </p>

      <h3>Fase II: Crear modelo conceptual</h3>
      <p>
        Se crea un modelo a partir de conceptos obtenidos, las asociaciones (relaciones) entre conceptos y los atributos que se conocen de cada uno.
      </p>
      <ul>
        <li>Las <b>asociaciones</b> son relaciones entre conceptos e indican conexiones entre ambos elementos. Estas relaciones tienen sentido dentro del mundo (del dominio) de los casos de uso. Algunas relaciones típicas pueden ser: A es parte de B, A usa o gestiona B, A es una descripción de B, A posee B, etc.</li>
        <li>Los <b>atributos</b> proporcionan información adicional de los distintos conceptos (características o propiedades) y deben tomar valores simples: un número, un texto, etc. (los tipos complejos se modelarán como conceptos)</li>
      </ul>
      <p>
        Es importante tener en cuenta que no es un concepto definitivo. Es una primera aproximación. Se refinará a lo largo del Análisis y del Diseño (y prácticamente se reconvertirá en el Diagrama de Clases)
      </p>
      <p>Conceptos + Asociaciones + Atributos = Modelo Conceptual</p>

    <h2>Clases, atributos y operaciones</h2>
      <p>
        Una <b>clase</b> es un patrón para definir métodos y atributos que caractericen a un posible objeto.
      </p>
      <p>
        Cualquiera de los objetos creados a partir de una clase es idéntico en forma y en comportamiento, no así en sus características ya que precisamente son sus atributos los que diferencian uno de otro.
      </p>
      <p>
        Una clase se representa mediante una caja rectangular subdividida en tres partes:
      </p>
      <ul>
        <li><i>Parte superior:</i> se indica el nombre de la clase.</li>
        <li><i>Parte media:</i> los atributos de la clase.</li>
        <li><i>Parte inferior:</i> las operaciones.</li>
      </ul>
      <p>
        La clase puede representarse, también, de forma esquemática, con los detalles suprimidos (atributos y operaciones), siendo entonces tan sólo un rectángulo con el nombre de la clase.
      </p>
      <p>
        Una misma clase puede representarse a disntinto nivel de detalle según interese, y según la fase en la que se esté.
      </p>
      <ol>
        <li>La clase "MiClase" plegada (con los detalles suprimidos)</li>
        <li>La clase "MiClase" con detalles a nivel de análisis. Muestra los atributos y los métodos.</li>
        <li>La clase "MiClase" con detalles de implementación. Muestra los atributos y los métodos pero se indica el tipo de cada uno de ellos.</li>
      </ol>
      <img src=".." alt="$$$ Imagen de clase 'MiClase' 1) solo nombre. 2) nombre, atributos y operaciones simple. 3) igual a 2 pero más detallado $$$">
      <p>Ejemplo - Clase punto</p>
      <ul>
        <li>Nombre: Punto</li>
        <li>Atributos: posX, posY</li>
        <li>Métodos: cambiarPosicion(nuevoX, nuevoY), darPosX(), darPosY()</li>
      </ul>
      <img src=".." alt="$$$ Imagen de clase 'Punto' con los 3 niveles de detalle $$$">

    <h2>Objetos</h2>
    <p>
      Los <b>objetos</b> o <b>instancias</b> son entidades atómicas que integran estado y comportamiento.
    </p>
    <p>
      Los objetos incluyen un <b>identificador</b> que les permite, como mínimo, una diferencia a cada uno de los objetos existentes. Este identificador es único y global para cada objeto del sistema.
    </p>
    <p>
      Los objetos se crean a partir de las clases particulizando los atributos existentes.
    </p>
    <p>
      Por ejemplo, a partir de la clase coche se pueden obtener tres objetos con diferente atributo marca: Toyota, BMW y Renault.
    </p>
    <p>
      Los objetos tienen la misma representación que las clases pero con dos particularidades:
    </p>
    <ul>
      <li>Los atributos se conretan para el objeto en cuestión.</li>
      <li>En la parte superior aparece el nombre del objeto junto con el nombre de la clase (subrayados), siguiendo la sintaxis: <code>nombre_del_objeto:nombre_de_la_clase</code>.</li>
    </ul>
    <img src=".." alt="$$$ Imagen de los objetos 'p1:Punto' y 'p2:Punto' $$$">


    <h2>Diagrama de Clases</h2>
      <p>
        El <b>diagrama de clases</b> permite visuallizar las clases existentes en la aplicación y las relaciones entre éstas.
      </p>
      <p>
        Los elementos (y los conceptos necesarios) que componen el Diagrama de Clases son:
      </p>
      <ul>
        <li><i>Clase:</i> atributos, métodos y visibilidad.</li>
        <li><i>Relaciones:</i> herencia, composición, agregación y asociación.</li>
      </ul>

      <h3>Clases</h3>
        <p>
          La <b>clase</b> es la unidad básica que encapsula toda la información de un Objeto. La clase se representa por un rectángulo con tres divisiones:
        </p>
        <img src=".." alt="$$$Rectangulo con tres divisiones: 'nombre Clase', 'Atributos' y 'Métodos'$$$">
        <p>
          Las clases se componen de atributos (información o propiedad inherente a todos los objetos de la clase) y operaciones o métodos (funciones proporcionadas por la clase). 
        </p>
        <p>
          Las clases se identifican de forma "TOP-DOWN", es decir, de los elementos generales a los elementos particulares.
        </p>
        <p>
          Las clases son los elementos físicos y lógicos dentro del sistema.
        </p>
        <p>
          Cada clase define el ámbito de definición de un conjunto de objetos (las instanciaciones de las propias clases).
        </p>

      <h3>Atributos</h3>
        <p>
          Se trata de localizar las características que determinarán las diferencian entre un objeto y otro. Por ejemplo, en la clase Persona se necesita del atributo DNI que permita identificarlo de forma única.
        </p>
        <p>
          Los atributos, características o propiedades de una Clase puedens er de tres tipos, dependiendo del grado de comunicación y visibilidad de ellos con el sistema:
        </p>
        <ul>
          <li><b>public:</b> Se denotan con el símbolo <b>(+)</b>, e indica que el atributo será visible tanto dentro como fuera de la clase. Este atributo es accesible desde cualquier punto.</li>
          <li><b>private:</b> Se denotan con el símbolo <b>(-)</b>, e indica que el atributo sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden acceder a él.</li>
          <li><b>protected:</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el atributo no es accesible desde fuera de la clase, pero, si es heredado, los métodos de la clase y las subclases pueden acceder a él.</b></li>
        </ul>

      <h3>Métodos</h3>
        <p>
          Los métodos de una clase constituyen la única forma de interacción entre los distintos objetos.
        </p>
        <p>
          Si se implementan de forma correcta los principios de <b>encapsulación</b>, los métodos son los elementos que acceden a cada uno de los atributos.
        </p>
        <p>
          Los métodos pueden tener estas visibilidades:
        </p>
        <ul>
          <li><b>public:</b> Se denotan con el símbolo <b>(+)</b>, e indica que el método será visible tanto dentro como fuera de la clase. Este método es accesible desde cualquier punto.</li>
          <li><b>private:</b> Se denotan con el símbolo <b>(-)</b>, e indica que el método sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden hacer uso de él.</li>
          <li><b>protected:</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el método no es accesible desde fuera de la clase, pero, si es heredado, otros métodos de la clase y las subclases pueden ser usados.</b></li>
        </ul>
        <p>
          El conjunto de métodos de una clase se denomina <b>protocolo</b> de la case.
        </p>
        <p>
          Por ejemplo, en una cuenta bancaria:
        </p>
        <ul>
          <li>Atributos:</li>
          <ul>
            <li>-numeroCuenta : int &#8594; Un número que identifica la cuenta.</li>
            <li>-balance: int &#8594; Muestra la cantidad de dinero depositada.</li>
          </ul>
          <li>Métodos:</li>
          <ul>
            <li>+balance() : int &#8594; Devuelve la cantidad existente en el depósito.</li>
            <li>+ingresar(entrada cantidad : int) : void &#8594; Ingresa la cantidad especificada aumentando el valor del atributo balance.</li>
            <li>+pago(entrada cantidad : int) : bool &#8594; Indica si la operación de pago ha sido positiva (TRUE) o negativa (FALSE)</li>
          </ul>
        </ul>
        <img src="" alt="$$$Insertar imagen Clase 'CuentaBanco' $$$">

        <p>
          Pasos para realizar un Diagrama de Clases
        </p>
        <ul>
          <li>Identificar las clases a partir de los Diagramas de Interacción.</li>
          <li>Colocar las clases en el Diagrama.</li>
          <li>Insertar los atributos obtenidos en el Diagrama Conceptual.</li>
          <li>Insertar los atributos obtenidos en los Diagramas de Interacción.</li>
          <li>Dar a cada método o atributo un tipo.</li>
          <li>Indicar las asociaciones entre clases.</li>
        </ul>


    <h2>Modelado de relaciones</h2>
      <p>
        Las asociaciones entre dos clases se representan mediante una línea gráfica entre ellas. Esta línea incluirá una serie de elementos gráficos que indican el tipo de asociación.
      </p>
      <p>
        El nombre de la asociación es opcional, pero debe expresarse en aquellos casos en los cuales no se entienda bien la relación entre las clases. El nombre de la relación se indica con un texto próximo a la línea.
      </p>
      <p>
        Se puede añadir, además, un pequeño triángulo de color negro para indicar la dirección en la cual leer el nombre de la asociación (una relación puede ser 'A es hijo de B' pero también valdría 'B es padre de A')
      </p>
      <p>
        La semántica de las relaciones dependerá de los objetos. Ellos darán significado a la relación.
      </p>
      <p>
        Por ejemplo pueden existir las relaciones: Un objeto de la clase Conductor conduce un objeto de la clase Coche; un objeto de la clase Perro es mascota de un objeto de la clase Persona.
      </p>
      <img src="" alt="$$$ Imagen de Relaciones Conductor-Coche Perro-Persona $$$">
      <p>
        El hecho de incluir nombres sólo afecta a la legibilidad del modelo, pero hay que utilizarse con discreción, porque si es demasiado abundante la información presentada, existe el consiguiente riesgo de saturación de información.s
      </p>

      <h3>Multiplicidad</h3>
        <p>
          La <b>multiplicidad</b> constituye una restricción que se pone a una asociación ya que indica el número de instancias de una clase que pueden tener esa asociación con una instancia de la otra clase.
        </p>
        <p>
          El decir que se indica el número de instancias, involucra que se limita el número de clases. Por ejemplo, un hijo tiene sólo un padre, pero un padre puede tener de 0 a n hijos.
        </p>
        <p>
          La multiplicidad se expresa de cualquiera de estas formas:
        </p>
        <ul>
          <li><b>1</b> &#8594; Uno y sólo uno</li>
          <li><b>0..1</b> &#8594; Cero o uno</li>
          <li><b>M..N</b> &#8594; De M a N (sólo enteros positivos)</li>
          <li><b>*</b> &#8594; De cero a varios</li>
          <li><b>0..*</b> &#8594; De cero a varios</li>
          <li><b>1..*</b> &#8594; De uno a varios</li>
        </ul>
        <p>
          La multiplicidad se indica en el Diagrama colocando a ambos lados de la línea al número de instancias.
        </p>
        <p>En el primer caso el abuelo puede tener desde un nieto hasta N (como mínimo debe tener un nieto porque sino no tendría sentido el rol de abuelo). Un nieto puede tener 4 abuelos (no se considera si están vivos o no)</p>
        <p>En el segundo caso, la familia puede tener dsde 0 a N mascotas. Sin embargo la mascota puede pertenecer a una sola familia.</p>
        <img src="" alt="$$$ Imagen Multiplicidad Abuelo-nuetos y gato-familia $$$">

      <h3>Roles</h3>
        <p>
          Los <b>roles</b> pueden utilizarse para indicar el papel que juega una clase en una asociación. Se colocan en cada uno de los extremos de la asociación junto a la clase que desempeña dicho rol. Así mismo, describe una semántica teniendo siempre en cuenta el sentido escogido.
        </p>
        <p>
          En el ejemplo siguiente, se expresa una relación paternal con los dos roles implicados. Además, en este caso, las clases son iguales. El rol marcará lo que se incluya en cada clase y lo que se guarde en la base de datos.
        </p>
        <img src="" alt="$$$ Imagen Roles clase Persona y los roles padre/hijo $$$">

      <h3>Relación de Agregación</h3>
        <p>
          La <b>agregación</b> o <b>parte_de</b> es una relación que implica a un objeto que está compuesto por otros objetos. Es un tipo de relación dinámica en la cual la duración del objeto incluido es independiente del objeto que lo incluye (por ejemplo, una rueda puede existir sin que esté la clase coche).
        </p>
        <p>
          La clase agregación se representa con un ícono transparente en forma de diamente colocado en el extremo en el que está la clase que representa la parte genérica. En el ejemplo, la clase coche podría formarse a partir de las clases Motor, Chasis, Ruedas e Interior.
        </p>
        <img src="" alt="$$$ Imagen Relación de agregación Coche-(Chasis,Ruedas,Motor,Interior) $$$">

      <h3>Relación de Asociación</h3>
        <p>
          La <b>asociación</b> expresa una relación semántica bidireccional entre dos clases. Si una asociación tiene propiedades privativas, se representa como una clase unida a la línea de asociación por medio de una línea punteada.
        </p>
        <p>
          La asociación entre clases permite relacionar objetos que colaboran entre sí, pero no es una relación fuerte, es decir, el tiempo de vida de un objeto no depende del otro. Esta característica existe también en la agregación, esto debido a que la <i>Agregación es un caso particular de Asociación</i>.
        </p>
        <p>
          En el ejemplo siguiente se muestra una relación de asociación y la modificación a realizar cuando la relación tiene atributos.
        </p>
        <img src="" alt="$$$ Imagen Asociacion Persona-Empresa con atributo salario $$$">

      <h3>Asociaciones n-arias</h3>
        <p>
          En las relaciones n-arias participan más de dos clases y se representan mediante un rombo central que une con líneas todas las clases.
        </p>
        <p>
          Si en un rol determinado se muestra la multiplicidad, ésta indicará el número potencial de tuplas de instancias en la asociación cuando el resto de valores sean fijos.
        </p>
        <p>
          En el ejemplo siguiente, se muestran 3 clases pero es la clase ciclista la que marca el sentido: puede correr N vueltas en un año, sólo puede estar en un equipo, etc.
        </p>
        <img src="" alt="$$$ Imagen Asociacion n-aria Ciclista-Vueltas-Equipo $$$">

      <h3>Relación de Herencia</h3>
        <p>
          La <b>relación de herencia</b> establece vínculos padre-hijo entre clases. Posibilita que una clase sea padre de otra, con lo que la clase hija comparte sus atributos, servicios, etc.
        </p>
        <p>
          La herencia es una relación <i>B es un A</i>. Permite que una <b>subclase</b> herede los métidos y atributos especificados por una <b>Super Clase</b>. En otras palabras, la subclase dispondrá de los métodos y atributos de la calse padre, y además poseerá sus propios métodos y atributos.
        </p>
        <p>
          La relación de herencia se representa con una línea contínua terminada en un triángulo en el extremo de la relación que corresponde a la clase más general o clase "padre".
        </p>
        <p>
          En el ejemplo siguiente, aparecen las clases Coche y Camion que heredan de la clase Vehículo. La clase Coche dispondrá de los atributos y métodos de Vehículo y, además, incorpora dos atributos como son ocupantes y capota. En el caso de la clase Camión también hereda atributos y métodos de Vehículo pero incorpora dos atributos como son la Tara y la Carga. La herencia permitirá tanto a la clase coche como camión, emplear las clases y atributos de Vehículo sin tener que declararlas.
        </p>
        <img src="" alt="$$$ Imagen Herencia Vehículo-(Coche,Camión) $$$">
        <p>
          En algunos casos, el número de clases que heredan es excesivo y no hay sitio para representarlas. Si ocurre este proble se pueden emplear puntos suspensivos.
        </p>
        <img src="" alt="$$$ Imagen Herencia Departamentos-(RRHH,Direccion,Tecnologia,...) $$$">

      <h3>Relación de Dependencia (o uso)</h3>
        <p>
          La <b>Relación de Dependencia (o uso) </b> se utiliza para mostrar una dependencia de una clase hacia otra. Se utiliza una línea punteada direccional que indique el sentido de la dependencia para mostrarlo de forma gráfica.
        </p>
        <p>
          Es una <i>relación semántica</i> entre dos elementos del modelo. Indica que los cambios realizados en la clase independiente pueden demandar cambios en las clases dependientes.
        </p>
        <p>
          En el ejemplo siguiente, la clase Ventana depende de la clase InterfazGrafica (la creación de objetos de clase Ventana se han condicionado a la instanciación provenientes desde la clase InterfazGrafica)
        </p>
        <img src="" alt="$$$ Imagen Relacion de Dependencia InterfazGrafica-Ventana $$$">


    <h2>Visibilidad y alcance</h2>
      <p>
        El concepto de <b>visibilidad</b> se atribute a los atributos y los métodos. Indica la posibilidad de que estos elementos puedan ser utilizados por otras clases.
      </p>
      <ul>
        <li><b>public (o públicos):</b> Se denotan con el símbolo <b>(+)</b>, e indica que el atributo o método será visible (y por lo tanto puede utilizarse) tanto dentro como fuera de la clase.</li>
        <li><b>private (o privados):</b> Se denotan con el símbolo <b>(-)</b>, e indica que el atributo o método sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden acceder a él.</li>
        <li><b>protected (o protegidos):</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el atributo o método no es accesible desde fuera de la clase, pero, si es heredado, los métodos de slas subclases pueden acceder.</b></li>
      </ul>
      <p>
        Se emplea esta técnica para proteger los datos de cualquier tipo de acceso no permitido.
      </p>
      <p>
        En el ejemplo siguiente, los atributos puertas y ruedas son protegidos mientras que el atributo velocidad es privado. El atributo marca es público.
      </p>
      <img src="" alt="$$$ Imagen clase 'Vehículo' $$$">

    </article>

    <article>
    <h1 id="diagramas_caso_uso">Diagramas de Casos de Uso</h1>

    <h2>Requisitos del sistema</h2>
      <p>
        El análisis de un sistema empieza siempre con la especificación de requisitos. Un <b>requisito</b> es una descripción de las necesidades que plantea el sistema. Por lo tanto, el objetivo de esta educción de requisitos es la identificación de las peticiones realizadas por el cliente para poder transmitirlas al equipo de desarrollo.
      </p>
      <p>
        Los puntos principales que hay que analizar en esta fase son:
      </p>
      <ul>
        <li>Funcionalidad del sistema</li>
        <li>Ámbito de actuación</li>
        <li>Objetivos</li>
        <li>Atributos y propiedades del sistema</li>
      </ul>

    <h2>Diagramas de Casos de Uso</h2>
      <p>
        El documento de especificación de requisitos comentado anteriormente, no viene incluido en la notación UML, pero los casos de uso constituyen una buena aportación para mejorar la comprensión de los requisitos y su posterior refinación.
      </p>
      <p>
        Los casos de uso son diagramas que establecen una idea dinámica y determinan como el sistema y las clases cambian con el tiempo.
      </p>
      <p>
        Un <b>diagrama de Casos de Uso</b> muestra las distintas operaciones que se esperan de una aplicación o sistema y cómo se relaciona con su entorno (usuarios u otras aplicaciones). Por lo tanto, los casos de uso se parecen a las especificaciones funcionales.
      </p>
      <p>
        Para construir un diagrama de caso de uso, se necesita unos actores, los casos de uso a considerar y las relaciones existentes entre ambos.
      </p>

    <h2>Casos de Uso</h2>
      <p>
        Los casos de uso representarán las tareas y responsabilidades de cada uno de los actores. Es una narración (en lenguaje natural) para describir la secuencia de interacciones entre un actor y el sistema.
      </p>
      <p>
        Fueron creados por Ivar Jacobson y cubren las carencias de modelos (OMT y Booch) en cuanto a la determinación de requisitos.
      </p>
      <p>
        Los casos de uso permiten encontrar los límites de sistema. Deben ser siempre simples, inteligibles, claros y concisos.
      </p>
      <p>
        Para representarlos de forma gráfica se utilizan elipses acompañadas de un nombre significativo que indique un proceso concreto. Cada caso de uso constituye una operación completa.
      </p>
      <p>
        Un aspecto a tener en cuenta es el nivel de abstracción que tienen los casos de uso. En primera instancia conviene crear casos de uso de Alto Nivel (desde su nivel de abastracción más alto). En estos casos de uso la descripción es muy general, con pocas frases. Por tanto su objetivo se centra en adquirir nociones del ámbito y de la complejidad del sistema.
      </p>
      <p>
        Los casos de uso que más influyan en el resto y en general, los casos más importantes, se explotarán en un nuevo nivel de detalle, dando lugar a los casos de Uso Expandidos.
      </p>
      <p>
        En el ejemplo se observa como el Caso de uso Hacer Declaracion de la Renta puede a su vez subdividirse en otros niveles que maticen el modelo con el que se está trabajando.
      </p>
      <img src="" alt="$$$ Imagen casos de uso 'Hacer Declaracion de la Renta' $$$">

      <p>
        Para encontrar casos de uso se puede realizar un proceso de brainstorming dentro del grupo de desarrollo o análisis, tomando como referencia preguntas del estilo:
      </p>
      <ul>
        <li>¿Cuáles son las operaciones más importantes del sistema?</li>
        <li>¿Cuáles son las principales tareas y responsabilidades de un actor?</li>
        <li>¿Qué datos posee el actor para consultar, actualizar, modificar o borrar?</li>
        <li>¿Qué cambios externos debe informar al sistema? ¿Son necesarios?</li>
        <li>¿Qué casos de uso crearán, borrarán, consultarán o modificarán?</li>
        <li>¿Qué información ncesita el actor de parte del sistema?</li>
        <li>¿Qué casos de uso dan soporte y mantendrán el sistema?</li>
      </ul>

      <p>
        Si bien no existen normas escritas para el desarrollo de casos de uso, se suelen seguir las siguientes pautas:
      </p>
      <ul>
        <li>Los casos de uso no utilizan lenguaje real. Por ejemplo si se realiza un caso de uso para operar con un cajero, se emplea la palabra código no PIN. A posteriori se puede revisar el caso de uso y adaptarlo.</li>
        <li>Conviene crear al principio casos de uso de alta nivel (más genéricos) e irlos refinando.</li>
        <li>El nombre de los casos de uso debería ser un verbo. De esta forma se acentúa la idea de estar trabajando con procesos.</li>
      </ul>
      <p>
        Los casos de uso se describen de forma gráfica y/o textual. Si se opta por el formato texto, se puede seguir el siguiente guión:
      </p>
      <ul>
        <li>Nombre Caso de Uso</li>
        <li>Objetivo</li>
        <li>Actores implicados</li>
        <li>Descripción</li>
        <li>Secuencia de acciones</li>
      </ul>
      <p>
        Por ejemplo si se desea realizar los casos de uso de un cajero automático, se deben detallar los pasos a realizar el cliente para poder realizar un reintegro y retirar dinero del cajero.
      </p>
      <ul>
        <li>Caso de Uso: Cajero Automático (Reintegro)</li>
        <li>Objetivo: Desarrollar una operación de reintegro en un cajero.</li>
        <li>Actores: Cliente, Cajero</li>
        <li>Descripción: El cliente llega al cajero. Inserta su tarjeta en la correspondiente ranura y marca su identificación personal. Del menú de opciones ofrecido, el cliente elige reintegro. Indica la cantidad que va a retirar. El cajero comprueba que existe dinero en la cuenta asociada y si es así, proporciona al cliente el dinero y le devuelve la tarjeta. El cliente se va.</li>
      </ul>
      <p>Secuencia de acciones:</p>
      <table style="width:100%">
        <tr>
          <td>CLIENTE</td>
          <td>SISTEMA DEL CAJERO</td>
        </tr>
        <tr>
          <td>(1) El cliente inserta la tarjeta</td> 
          <td></td>
        </tr>
        <tr>
          <td></td>    
          <td>(2) Pide la identificación</td>
        </tr>
        <tr>
          <td>(3) Teclea la contraseña</td>    
          <td></td>
        </tr>
        <tr>
          <td></td>    
          <td>(4) Muestra el menú de opciones</td>
        </tr>
        <tr>
          <td>(5) Selecciona la operación "Reintegro"</td>    
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>(6) Pregunta la cantidad</td>
        </tr>
        <tr>
          <td>(7) Escribe la cantidad necesaria</td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>(8) Procesar la operación</td>
        </tr>
        <tr>
          <td></td>
          <td>(9) Emitir recibo. Devolver tarjeta. Dar dinero</td>
        </tr>
        <tr>
          <td>(10) Recoger tarjeta, recibo y dinero.</td>
          <td></td>
        </tr>
      </table>

      <p>
        En el caso anterior, no se ha simulado la existencia de problema. De ser así habría que indicar las secuencias alternativas.
      </p>
      <ul>
        <li>En el caso (4) Muestra el menú de opciones, si la contrasela no es correcta se marca el error y se pude una nueva clave (hasta un máximo de tres)</li>
        <li>Para el caso (8) Procesar la operación puede ocurrir que la cantidad reclamada sea superior al saldo de la cuenta asociada. Habrá que indicar el error y pedir una cantidad menor.</li>
      </ul>

    <h2>Actores</h2>
      <p>
        Representan a los agentes que interactúan con el sistema. Por tanto, no forman parte del sistema pero si lo introducen y/o reciben información de él.
      </p>
      <p>
        Los actores se representan con un símbolo esquemático seguido de un nombre que sea significativo (siempre y cuando fuera necesario).
      </p>
      <p>
        Una misma persona física puede desempeñar varios papeles de actor. Existen varias categorías:
      </p>
      <ul>
        <li><b>Principales:</b> personas que utilizan el sistema.</li>
        <li><b>Secundarios:</b> administradores del sistema.</li>
        <li><b>Externos:</b> dispositivos materiales que deben utilizarse en el sistema.</li>
        <li><b>Otros sistemas:</b> sistemas que interactúan.</li>
      </ul>
      <p>
        Para encontrar los actores se pueden realizar las siguientes preguntas:
      </p>
      <ul>
        <li>¿Se puede identificar a los usuarios del sistema?</li>
        <li>¿Quién está interesado en un requirimiento concreto?</li>
        <li>¿Quién proporciona o recibe información del sistema?</li>
        <li>¿Algún agente dispone de varios roles?</li>
        <li>¿Quién da soporte al sistema? ¿Quién administra?</li>
        <li>¿Quiénes interactúan de forma directa con el sistema?</li>
        <li>¿Hay sistemas con los cuales se comunica?</li>
        <li>¿Cuál es el dominio del sistema?</li>
        <li>¿Se utilizan recursos externos?</li>
      </ul>
      <p>
        Los actores varían dependiendo del enterno en el que se sitúe el problema y la parte del mismo que se aborde.
      </p>
      <p>
        Por ejemplo, si se modela un sistema relativo a un centro de formación o academia. Los posibles actores que entrarían en juego serían:
      </p>
      <ul>
        <li>Actores para sistema de formación</li>
          <ul>
            <li>Profesores: los que imparten clases.</li>
            <li>Alumnos: personas matriculadas.</li>
            <li>Secretaria: persona que recibe al alumno a diario y tramita sus dudas.</li>
            <li></li>
          </ul>
        <li>Actores para sistema de ventas</li>
          <ul>
            <li>Cliente: potencial alumno.</li>
            <li>Comercial: persona que vende el curso.</li>
            <li>Jefe de comerciales: coordina a los comerciales y sus ventas.</li>
            <li>Secretaría: persona que matricula al alumno.</li>
          </ul>
      </ul>

    <h2>Relaciones</h2>
      <p>
        Las <b>relaciones</b> son las interacciones existentes entre actores y casos de uso o entre dos casos de uso. Se representan con una línea dirigida desde el elemento dependiente del elemento independiente y una etiqueta (&lt;).
      </p>
      <img src="" alt="$$$ Imagen relaciones reciclar y generar_informe $$$">

      <p>
        Existen tres tipos de relaciones:
      </p>
      <ul>
        <li><b>Comunica (communicates)</b>: Relación existente entre un actor y un caso de uso. Denota la participación del actor en el caso de uso determinado. Normalmente no se indica ya que las relaciones existentes entre el actor y el caso de uso son de este tipo.</li>
        <li><b>Usa (uses) (includes)</b>: Relación existente entre dos casos de uso. Denota la inclusión del comportamiento de un escenario en otro. Se marca con la notación <i>uses</i>. Desde UML 1.3 se especifica como includes.</li>
        <li><b>Extiende (extends)</b>: Relación existente entre dos casos de uso. Se produce cuando un caso de uso constituye una especialización de otro. Es un concepto similar a la herencia. Se marcan con la notación <i>extends</i>.</li>
        <li><b>Generalización (generalization)</b>: La descripción de un actor puede matizarse mediante esta asociación. Conceptualmente es similar al concepto de herencia de clases.</li>
      </ul>
      <p>
        Para detectar relaciones se puede realizar las siguientes preguntas:
      </p>
      <ul>
        <li><i>Relaciones communicates:</i> ¿En qué casos de uso se ve envuelto un actor?</li>
        <li><i>Relaciones extends:</i> ¿Qué casos de uso son similares? ¿Cuáles de ellos se diferencian en la forma de realizar y ejecutar la operación? ¿Qué casos redefinen la forma en la cual se realiza una transacción dentro de otro caso de uso?</li>
        <li><i>Relaciones uses:</i> ¿Qué casos se emplean como transiciones de otros? ¿en qué casos de uso se puede englobar un caso concreto?</li>
      </ul>


    <h2>Construcción del diagrama de Casos de Uso</h2>
      <p>
        Los pasos que pueden seguirse para construir un modelo de casos de uso durante la fase de análisis del problema son:
      </p>
      <ul>
        <li>Listar funciones del sistema y límites.</li>
        <li>Identificar actores.</li>
        <li>Indentificar casos de uso. Escribirlos.</li>
        <li>Realizar el diagrama de casos de uso.</li>
        <li>Indicar todas las relaciones existentes dentro del diagrama.</li>
        <li>Expandir y detallar los casos de uso más importantes.</li>
        <li>Crear casos de uso reales si fuera necesario.</li>
      </ul>

    </article>

    <article>
    <h1 id="diagramas_interaccion">Diagramas de Interaccion</h1>
    <h2>Interacción</h2>
      <p>
        Un <b>escenario</b> describe la ejecución de un caso de uso a partir de las interacciones existentes entre los objetos. Un escenario es una instancia del caso de uso, es decir, muestra una ejecución real de un caso de uso planteando las distintas posibilidades, bifurcaciones y alternativas propuestas por el caso de uso pero adaptadas a unos valores concretos.
      </p>
      <p>
        Los <b>diagramas de interacción</b> permiten describir los escenarios. Pueden utilizarse dos tipos:
      </p>
      <ul>
        <li><i>Diagramas de Secuencia</i>: relacionan la interacción entre objetos con el tiempo de ejecución.</li>
        <li><i>Diagramas de Colaboración</i> (en UML 2.0, <i>Diagramas de Comunicación</i>): se centran en las relaciones entre objetos.</li>
      </ul>

    <h2>Diagramas de Secuencia</h2>
      <p>
        Un <b>diagrama de secuencia</b> muestra una secuencia cronológica de mensajes durante un escenario concreto, es decir, una secuencia ordenada de eventos.
      </p>
      <p>
        Los elementos que entran en juego en un diagrama de secuencia son:
      </p>
      <ul>
        <li><b>Objeto:</b> los objetos o actores se colocan en la parte superior (de izquierda a derecha) del diagrama sin un orden prefijado. Cada uno dispone de una línea vertical denominada <b>línea de vida</b>. Las características que marcan esta línea son:</li>
        <ul>
          <li>Es una línea discontínua.</li>
          <li>Los mensajes parten de una línea y van a otra.</li>
          <li>Los recuadros que aparecen sobre las líneas de la vida marcan la duración de una determinada operación y se denominan zona de activación.</li>
        </ul>
        <img src="" alt="$$$ Imagen objetos y línea de vida$$$">
        <li><b>Mensaje:</b> es la información o aviso intercambiado entre dos objetos. Se representa con una flecha que va desde una línea de vida a otra. Estos mensajes pueden ser:</li>
        <ul>
          <li><b>Asincrónico:</b> el envío de un mensaje asincrónico implica que no se necesita una respuesta para continuar la ejecución. En UML y las versiones se muestra como una flecha con media cabeza, a partir de UML 1.4 se dibuja como una flecha con la cabeza abierta.</li>
          <li><b>Sincrónico:</b> es necesario, para su correcto funcionamiento, esperar la respuesta al mensaje que se ha enviado antes de seguir con la ejecución.</li>
          <li><b>Simple:</b> transferencia básica de información y del control de un objeto a otro.</li>
        </ul>
        <img src="" alt="$$$ Imagen tipos de mensajes $$$">
        <li><b>Tiempo:</b> el tiempo se representa mediante el eje vertical. La parte superior del diagrama será el punto de partida, por tanto si un mensaje está más cerca de la parte inferior que otro, significa que ha ocurrido más tarde. En la siguiente imagen se observa los mensajes escalonados, lo que hace que dependan cronológicamente hablando de otros.</li>
        <img src="" alt="$$$ Imagen mensajes escalonados $$$">
      </ul>
      <p>
        Por ejemplo, para el diagrama de secuencia de una llamada telefónica se tiene:
      </p>
      <ul>
        <li>Objetos: persona que llama (emisor), persona que recibe la llamada (receptor) y la propia línea telefónica.</li>
        <li>Pasos:</li>
        <ul>
          <li>Emisor descuelga el teléfono.</li>
          <li>El teléfono le da línea.</li>
          <li>El emisor marca el número de teléfono.</li>
          <li>La línea telefónica manda un aviso al receptor, y, a la persona que llama, se le manda un tono de llamada en proceso.</li>
          <li>Si el receptor está, descuelga el teléfono.</li>
          <li>El receptor inicia la conversación con el emisor.</li>
        </ul>
      </ul>
      <img src="" alt="$$$ Imagen de diagrama de secuencia de llamada telefónica $$$">
      
      <p>
        El control que se traslada de un objeto a otro en los diagramas de interacción son de dos tipos:
      </p>
      <ul>
        <li><b>Control centralizado:</b> desde una línea de vida se mandan los mensajes a las otras líneas de vida.</li>
        <li><b>Control descentralizado:</b> cuando una línea de vida envía un mensaje, cede el control a esa nueva línea de vida.</li>
      </ul>
      <img src="" alt="$$$ Imagen de tipos de control en diagrama de secuencia $$$">

      <p>
        Para cada uno de los casos de uso existentes, debe realizarse un diagrama de secuencia que muestre el desarrollo normal de acciones. Además, se creará otro diagrama para las alternativas y bifurcaciones (aunque en algunos casos pueden integrarse en un único diagrama).
      </p>
      <p>
        Los objetos también pueden destruirse. El hecho de colocar un objeto en pantalla con su línea de vida, implica que ese objeto se ha creado. Si en su línea de vida se incluye un ícono de forma de aspa, significa que el ese punto temporal el objeto se ha destruido (en UML 2.0, el elemento que tiene la línea de vida no tiene porque ser un objeto -y no debería ser subrayado)
      </p>
      <img src="" alt="$$$ Imagen de diagrama de secuencia creación y destrucción de objeto $$$">


    <h2>Estructuras de los Diagramas de Secuencia</h2>
      <p>
        Existen varios tipos de estructuras:
      </p>
      <ul>
        <li><b>Secuenciales:</b> para representar una serie de acciones que se realizan de forma continuada (es decir, separadas por un margen de tiempo) se lanzan los mensajes desde una línea de vida separados por un lapso de tiempo.</li>
        <img src="" alt="$$$ Diagrama de secuencia con estructura secuencial $$$">
        <li><b>Reflexivas (o recursiva):</b> Un objeto puede enviarse mensajes a sí mismo, es decir, se invoca a sí mismo.</li>
        <img src="" alt="$$$ Diagrama de secuencia con estructura reflexiva $$$">
        <li><b>Condicionales:</b> cuando se necesita realizar una estructura condicional (if-then-else) se emplea una estructura similar a la figura, indicando tantos mensajes como condiciones existan. El mensaje se envía si se cumple esa condición. Se puede representar la condición entre corchetes o bien utilizando una expresión del tipo "IF..ELSE". Además la estructura también permitiría condicionales anidados mediante estructuras "ELSE..IF". Uno de los usos más frecuentes de esta estructura es la representación de los posibles problemas dados en el escenario (como en una llamada telefónica, cuando el receptor no descuelga el teléfono)</li>
        <img src="" alt="$$$ Diagrama de secuencia con condicionales $$$">
        <li><b>Iterativas:</b> cuando se necesita realizar una estructura iterativa (de tipo while) se emplea una estructura similar a la figura, indicando la acción a realizar mientras se cumpla la condición. Pueden representarse con un asterisco y entre corchetes los parámetros del bucle (aunque también se pueden indicar las instrucciones de iteración "WHILE" y "END WHILE").</li>
        <img src="" alt="$$$ Diagrama de secuencia con iterativas $$$">
        <li><b>Concurrencia:</b> la concurrencia implica dos o más tareas actuando de forma simultánea. Estos diagramas de secuencia permiten mostrar la concurrencia cuando un objeto envíe más de un mensaje al mismo tiempo. Se representa con un un doble menzaje lanzado en el mismo momento pero a destinos diferentes.</li>
        <img src="" alt="$$$ Diagrama de secuencia con concurrencia $$$">
      </ul>

    <h2>Pasos para la construcción de un diagrama de secuencia</h2>
      <p>
        Los pasos para la construcción de un diagrama de secuencia son:
      </p>
      <ul>
        <li>Indentificar los objetos. Colocarlos de izquierda a derecha y añadir a cada uno su línea de vida.</li>
        <li>Identificar a los actores que operan contra el sistema y colocarles también su línea de vida (recordar que estos actores no portenecen propiamente al sistema)</li>
        <li>A partir de las interacciones expuestas en el caso de uso, identificar los eventos y representarlos mediante líneas que vayan de una línea de vida a otra.</li>
        <li>Identificar, además, el evento inicial.</li>
        <li>De forma opcional, se pueden colocar notas en el diagrama para su mayor comprensión. Las notas son unos elementos aportados por UML que pueden utilizarse en sus diagramas para explicar ciertos aspectos (se representan con un rectángulo con la esquina superior derecha doblada)</li>
      </ul>
      <img src="" alt="$$$ Diagrama de secuencia con notas en la parte inferior $$$">

    <h2>Diagramas de colaboración</h2>
      <p>
        Este tipo de diagrama se centra en los objetos. El <b>diagrama de colaboración</b> muestra los roles de cada uno de los objetos y constituye una de las mejores herramientas para identificarlos.
      </p>
      <p>
        El diagrama representa los objetos, los enlaces existentes y, mediante flechas, los mensaje sque circulan entre ellos. Estos mensajes incorporan el nombre del mensaje y los parámetros en caso de que los hubiese.
      </p>
      <p>
        Aunque no existe una estructura tan cronológicamente ordenada como en los diagramas de secuencia, cada uno de los mensajes lleva un número de secuencia para indicar el orden de cada mensaje y saber, así, cuál se ha ejecutado antes y cuál se ejecutará a posteriori (el primier mensaje no lleva número de secuencia). Los diagramas de colaboración no reflejan temporalidad.
      </p>
      <img src="" alt="$$$ Diagrama de colaboración y su equivalente diagrama de secuencia $$$">

      <p>
        Para los diagramas de colaboración se emplean los siguientes elementos:
      </p>
      <ul>
        <li><b>Enlaces:</b> representa una conexión entre dos objetos e indica que existe interacción entre ambos. Un enlace es una instancia de una asociación. Por un mismo enlace pueden enviarse varios mensajes.</li>
        <li><b>Mensajes:</b> es la información transmitida entre objetos. Se representa con una flecha que indica la dirección del mensaje. A este mensaje se le incorpora un número de secuencia para mostrar el orden (separado del nombre por dos puntos). El mensaje añade al final dos parentesis entre los cuales se indicarán los parámetros (en caso de que los hubiese). En algunos casos los mensajes se derivan de otros mensajes. Para indicarlo se emplea la estrucutra de numeración de los libros que utiliza puntos decimales para señalar los diferentes niveles de anidamiento.</li>
        <img src="" alt="$$$ Diagrama de colaboración $$$">
      </ul>


    <h2>Estructuras de los diagramas de colaboración</h2>
    <p>
      Existen varios tipos de estructura en los diagramas de colaboración:
    </p>
    <ul>
      <li><b>Reflexiva:</b> el objeto se envía el mensaje así mismo. Se representa con un enlace con origen y destino en propio objeto. Además, hay que añadir el sentido de la flecha y el nombre de la acción.</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura reflexiva $$$">
      <li><b>Condicionales:</b> se representan con un número de secuencia y una sentencia condicional encerrada entre corchetes. La única forma de enviar el mensaje es que la cláusula sea verdadera. Al  agregar condiciones se incorpora una bifurcación. Se coloca la condición entre corchetes y estos anteceden el número de orden. En la primera imagen, si pagado es TRUE se envía el mensaje levantar_barrera(). De forma adicional, se puede trabajar el caso en el caso en el cual no se cumpla la condición (en proframación se considera una estructura IF..ELSE). En ese caso se escribe, entre corchetes, la condición negada y, al igual que el caso del IF, se indica a continuación la acción a realizar. En la segunda imagen, se observa que ocurre en caso de que pagado no tenga el valor TRUE, enviando el mensaje pedirTicketValidado(). Para notarlo se incluye una letra después del número de orden (indica exclusividad)</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura condicional IF $$$">
      <img src="" alt="$$$ Diagrama de colaboración con estructura condicional IF..ELSE $$$">
      <li><b>Iterativas:</b> para indicar la iteración, se utiliza un asterisco justo después del número de secuencia y entre corchetes los parámetros del bucle. Esta estrucutra permite también enviar un mensaje a varios objetos de la misma clase (podría asemejarse al concepto de concurrencia).</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura iterativa $$$">
      <li><b>Cálculo de expresiones:</b> en algunos casos la operación realizada necesita que se desarrolle una determinada operación y devuelva un valor (el concepto clásico de función). Para indicarlo se emplea una expresión cuya parte izquiera sea la variable que recogerá el resultado y cuya parte derecha sea el cálculo realizado. Ambas partes se separan con <code>:=</code></li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura calculo de expresiones $$$">
    </ul>


    <h2>Pasos para la construcción de un diagrama de colaboración</h2>
      <p>
        Los pasos para construir un diagrama de colaboración son:
      </p>
      <ul>
        <li>Para cada una de las operaciones existentes en el sistema, se debe desarrollar un diagrama individual.</li>
        <li>Cada uno de los eventos del sistema se transforma en un diagrama que parte de ese evento como mensaje inicial.</li>
        <li>El sistema de objetos que realizan las tareas parte de la descripción del caso de uso y de las postcondiciones existentes.</li>
        <li>Hay que indicar la secuencialidad de cada mensaje mediante los números de orden.</li>
      </ul>
      <img src="" alt="$$$ Diagrama de colaboración con mensajes y secuencia $$$">


    <h2>Diferencias entre los diagramas de secuencia y colaboración</h2>
      <p>
        Si bien ambos diagrams son semánticamente equivalentes, es decir representan la misma información y pueden convertirse fácilmente entre ellos. Sin embargo existen las siguientes diferencias:
      </p>
      <ul>
        <li>Los diagramas de Colaboración suelen ser más cortos ya que cada mensaje en los Diagramas de Secuencia hay que representarlo en función del tiempo (en vertical).</li>
        <li>Los diagramas de Secuencia apuestan por la cronología. Los diagrams de Colaboración no reflejan temporalidad y es más difícil detectar la secuencialidad.</li>
        <li>La notación de los Diagramas de Secuencia es más fácil.</li>
        <li>Los diagramas de Colaboración muestran mejor el comportamiento concurrente.</li>
      </ul>
      <p>
        En la siguiente figura se puede ver que la activación en el Objeto1 del diagrama de secuencia no figura en el diagrama de colaboración.
      </p>
      <img src="" alt="$$$ Diagrama de colaboración y su equivalente diagrama de secuencia $$$">

    </article>

    <article>
    <h1 id="diagramas_estado_actividades">Diagramas de Estado y Actividades</h1>
    <h2>Concepto de estado</h2> 

      <p>
        Un <b>estado</b> indica un periodo de tiempo en la vida de un objeto. En este lapso de tiempo, el objeto está a la espera de alguna operación, acción, evento, etc. que permita activarlo y así pasar a otro estado.
      </p>

      <p>
        En UML los estados se representan mediante un rectángulo con los bordes redondeados. Esta caja puede tener divisiones dentro (como con las clases):
      </p>
      <ul>
        <li>Nombre del estado (que sea significativo)</li>
        <li>Acciones ejecutadas al realizar una operación relacionada con el estado (acceder, salir o permanecer)</li>
      </ul>
      <img src="" alt="$$$ Imagen estado con dos acciones $$$">

    <h2>Diagramas de estados</h2>

      <p>
        Un <b>diagrama de estados</b> muestra los distintos estados de los que dispone un objeto durante su vida, como se relacionan entre ellos y como responden a determinados eventos. Son los diagramas de transición de estados propuestos en la metodología Booch o los Diagramas de Estados de OMT.
      </p>
      <p>
        El diagrama de estados se representa con un grafo cíclico. Cada uno de los nodos es uno de los estados posibles y los arcos son transiciones dirigidas. Las flechas indican la interacción entre los dos estados.
      </p>

      <p>
        Cada uno de los diagramas de estado se corresponde con un método o una clase. Se usan para describir el comportamiento de un objeto a través de diferentes casos de uso y es muy útil combinarlo con otros modelos como, por ejemplo, los diagramas de actividades.
      </p>
      <p>
        En un diagrama de estados se incluye un estado inicial (creación) y un estado final (destrucción), pese a que estos estados no son utilizables ya que un objeto no puede estar en uno de ellos pero hace el diagrama más legible. Para representarlos se emplea un circulo sólido de color negro para el estado inicial y un círculo con un punto negro para el estado final.
      </p>
      <img src="" alt="$$$ Imagen diagrama de estados $$$">

    <h2>Transiciones y acciones</h2>

      <h3>Transiciones</h3>
      <p>
        Una <b>transición</b> es la respuesta que ofrece un objeto (mientras se encuentra en un estado concreto) al producirse un evento. Normalmente una transición puede llevar asociada una transformación de estado para el objeto. La transición entre estados es instantánea y se debe a los eventos que se van sucediendo.
      </p>
      <p>
        Estos eventos pueden ser de distintos tipos: recepción de un mensaje, un periodo de tiempo que se termina, una condición que toma o cambia su valor verdadero/falso, una señal a otro de los objetos del diagrama, etc.
      </p>
      <img src="" alt="$$$ Imagen diagrama de estados con transiciones $$$">

      <p>
        A una transición se le puede añadir una etiqueta que señale la condici
        on que debe cumplirse para pasar de un estado a otro y la acción correspondiente en caso de que esto ocurra. La etiqueta que se emplea tiene la siguiente sintaxis: Evento [condición] | Acción. El evento lanza un posible cambio de estado. Si se cumple la condición indicada (si su valor es TRUE), se ejecutará la acción que viene a continuación. Cada uno de los datos es opcional. Por ejemplo, si no se indica la condición significa que ante ese evento siempre se ejecuta la acción.
      </p>
      <img src="" alt="$$$ Imagen diagrama de estados con transiciones-condiciones $$$">

      <h3>Acciones</h3>
      <p>
        Las <b>acciones</b> son los comportamientos provocados cuando un evento afecta a un determinado estado. Las acciones incluidas en cada estado pueden ser de tres tipos:
      </p>
      <ul>
        <li><b>Acciones de entrada:</b> se ejecutan cada vez que se accede al estado.</li>
        <li><b>Acciones de salida:</b> cada vez que se sale del estado a través de una transición se ejecuta esta acción.</li>
        <li><b>Acciones internas:</b> estas acciones se efectúan cuando se recibe algún tipo de evento que no provoca un cambio de estado. No hay transición.</li>
      </ul>
      <img src="" alt="$$$ Imagen diagrama de estados con varias acciones del estado $$$">

    <h2>Subestados y superestados</h2>

      <p>
        En los Diagramas de Estado, un estado puede dividirse a su vez en varios subestados. Entre ellos hay que incluir las transiciones correspondientes para que se comuniquen y algún tipo de conexión para que se comuniquen con los estados superiores (los estados continentes se denomina <b>superestados</b> y los estados anidados se denominan <b>subestados</b>). Se utilizan para refinar el aspecto de un estado y describirlo de forma más concreta.
      </p>
      <img src="" alt="$$$ Imagen de superestado y subestados $$$">

      <p>
        Así como los estados pueden dividirse, también pueden ejecutarse de forma concurrente. Aunque cada una de las secuencias es un conjunto de subestados secuenciales, ambas son concurrentes entre sí. Se representa con un diagrama dividido en dos partes mediante una línea discontínua entre las secuencias concurrentes.
      </p>

      <p>
        En el siguiente ejemplo, se verifica que el cliente tuviese crédito suficiente y en caso de ser válido, autorizarlo; y en caso de surgir problemas cancelar el proceso. Por ese motivo se han añadido una serie de estados finales ["entregado" y "rechazado"] a los cuales se accede una vez realizadas las correspondientes secuencias.
      </p>
      <img src="" alt="$$$ Imagen diagrama de estados de un pedido $$$">

    <h2>Diagramas de Actividades</h2>
      <p>
        Los <b>diagramas de actividades</b> son extensiones de los diagramas de estados, sólo que en los diagramas de actividades los estados son de acción. En los diagramas de estados se muestran los estados de un objeto y muestra las actividades como flechas entre estado y estado. Estas actividades, son las que se desarrollan en los diagramas de actividades.
      </p>
      <p>
        Son parecidos a los clásicos diagramas de flujo, pero UML utiliza una adaptación con más posibilidades, como por ejemplo la concurrencia, aunque no deja de ser un organigrama: actividades, bifurcaciones y decisiones.
      </p>
      <p>
        Para representar el diagrama de actividades, se muestran las actividades encerradas entre rectángulos con los bordes redondeados. Se procesa la actividad y se pasa a la siguiente utilizando flechas para indicar las transiciones.
      </p>
      <img src="" alt="$$$ Imagen diagrama de actividades $$$">

    <h2>Estructura de los diagramas de actividades</h2>

      <h3>Condicionales</h3>
      <p>
        Las bifurcaciones pueden representarse de dos formas:
      </p>
      <ul>
        <li>Mostrando todas las rutas posibles.</li>
        <li>Indicando con un rombo la condición.</li>
      </ul>
      <p>
        Además, hay que señalar la condición entre corchetes. Todas las ramas que aparecen son exclusivas, es decir, si se accede a una de ellas no se puede encaminar por ninguna de las otras.
      </p>
      <img src="" alt="$$$ Imagen diagrama de actividades con condicionales $$$">

      <h3>Concurrentes</h3>
      <p>
        Consiste en separar una transición en dos rutas para que ambas se ejecuten en paralelo. Se representa mediante una línea gruesa que sea perpendicular a la transición que se haya partido. Las distintas divisiones toman esta línea como punto de partida.
      </p>
      <p>
        El reencuentro entre las rutas concurrentes se produce cuando desembocan a otra línea gruesa tal y como se observa en el gráfico adjunto.
      </p>
      <img src="" alt="$$$ Imagen diagrama de actividades con concurrentes $$$">

      <h3>Indicaciones o Señales</h3>
      <p>
        Las indicaciones son avisos enviados entre actividades para que se ejecute la actividad a la cual le llega el mensaje.
      </p>
      <p>
        Gráficamente el envío se representa mediante un pentágono convexo y la recepción mediante un pentágono cóncavo.
      </p>
      <img src="" alt="$$$ Imagen diagrama de actividades con indicaciones/señales $$$">

    <h2>Marcos de responsabilidad ("swim lanes)</h2>
      <p>
        Una de las posibilidades de los diagramas de actividades, es mostrar las responsabilidades embebidas dentro de cada actividad (ya que siempre debe existir un responsable de cada una). Para representarlas se emplea un diagrama con tantas bandas o particiones verticales (<b>swim lanes</b>) como roles existan en el problema. A estos segmentos se les conoce como <b>marcos de responsabilidad</b>.
      </p>
      <p>
        En cada banda se indica en la parte superior el nombre del rol o responsable de actividad. Se adapta y moldea el diagrama para que cada actividad caiga en la banda correspondiente. Las transciciones son las responsables de saltar de un marco a otro.
      </p>
      <img src="" alt="$$$ Imagen diagrama de marcos de responsabilidad $$$">

    </article>

    <article>
    <h1 id="modelado_fisico">Modelado físico de un sistema</h1>  
    <h2>Paquetes</h2>
    <p>
      Un <b>paquete</b> es un mecanismo que permite organizar elementos del modelo en grupos. Los paquetes también pueden agruparse en otros paquetes como si de una estructura jerárquica se tratara. Cada uno de los paquetes se subdividiría a su vez en otros subpaquetes. Los paquetes se corresponden con los namespaces de .NET (las clases existentes deben tener un nombre único) o los packages de Java. Por este motivo, estas técnicas son útiles cuando los sistemas son extensos ya que tienen una correspondencia directa con los lengaujes de programación más utilizados.
    </p>
    <p>
      Para representarse de forma gráfica, UML emplea un rectángulo con una lengueta en la parte superior izquierda. Hay tres formas de representarlos:
    </p>
    <ul>
      <li>El paquete lleva el nombre en el interior.</li>
      <li>Las clases aparecen listadas en el interior.</li>
      <li>Las clases aparecen de forma gráfica en el interior.</li>
    </ul>
    <img src="" alt="$$$ Imagen de paquetes $$$">
    <p>
      En general un paquete puede agrupar cualquier elemento de UML, pero sobre todo, suele utilizarse con clases. Cada elemento pertenece a (o está definido en) un paquete. Los paquetes pueden tener dependencias entre ellos. Estos conjuntos de asociaciones deben tener una estructura armoniosa y bien balanceada (es fácil reconocerlos porque normalmente el sentido de las dependencias fluye en una misma dirección).
    </p>
    <p>
      La relación de dependencia se indica con una línea punteada terminada en flecha. Si la flecha va desde un paquete A a un paquete B, significa que el paquete A depende del paquete B. Conviene que no existan ciclos entre los distintos paquetes. Los elementos pertenecen al paquete, pero suelen ser referenciados desde otros paquetes. Para hacerlo hay que anteponer el nombre del elemento, el nombre del paquete en el que se ha definido seguido de <code>::</code>.
    </p>
    <img src="" alt="$$$ Imagen de paquetes con estructura UML $$$">

    <h2>Componentes e interfaces</h2>
      <p>
        Los diagramas vistos hasta el momento se centran en los conceptos: muestro las clases o abstracciones del mundo real, muestro los mensajes, muestro los estados por los que pasa un objeto, etc. Sin embargo, los componentes representan una parte física de un sistema (un fuente, un binario, un ejecutable)
      </p>
      <img src="" alt="$$$ Imagen de componentes e interfaz gráfica $$$">

      <p>
        Existen tres tipos de componentes:
      </p>
      <ul>
        <li><b>Componentes de despliegue o distribución</b>: son los que se necesitan para formar un sistema ejecutable (las DLLs, los ActiveX, etc.)</li>
        <li><b>Componentes de producción</b>: de estos se conforman los componentes de distribución (el código fuente, archivos de bases de datos, etc.)</li>
        <li><b>Componentes de ejecución</b>: creados a partir de un sistema en ejecución.</li>
      </ul>
      <p>Se representan mediante un rectángulo con dos rectángulos insertos en su parte izquierda. En la notación UML 2.0 la representación es diferente.</p>

    <h2>Diagrama de componentes (despliegue?)</h2>
      <p>
        Los componentes utilizan interfaces para comunicarse. Una interface es un conjunto de operaciones que especifican los servicios que ofrece ese componente. Es la cara del componente.
      </p>
      <p>
        Las interfaces pueden ser de dos tipos:
      </p>
      <ul>
        <li><b>Interfaz de exportación</b>: el componente provee esa interfaz.</li>
        <li><b>Interfaz de importación</b>: el componente requiere esa interfaz para poder trabajar.</li>
      </ul>
      <p>
        Además los componentes puede relacionarse entre sí. Un <b>diagrama de componentes</b>, es el conjunto de componentes, interfaces y sus relaciones.
      </p>
      <p>
        Los componentes pueden intercambiarse en un diagrama. Basta con que mantengan las mismas interfaces y se modifique el componente. De hecho, uno de los factores más importantes de los componentes es que pueden reutilizarse. Se representan como un gráfico de componentes software unidos por medio de relaciones de dependencia
      </p>
      <img src="" alt="$$$ Imagen de diagrama de componentes $$$">


    <h2>De UML a los lenguajes de programación</h2>
    <p>
      Java y VB.NET son dos de los lenguajes más utilizados para el trabajo con UML, debido, sobre todo, a su clara orientación hacia el mundo de los objetos. Sin embargo existe una gran diferencia entre ellos. VB .NET es un entorno de trabajo y proporciona herramientas para trabajar de forma directa. Java es un lenguaje y existen numerosos compiladores. Para trabajar con Java deben utilizarse plugins como Borland Together u Omondo, ambos para Eclipse.
    </p>
    <p>
      Al proceso consistente en generar código, tomando como referencia una serie de modelos, se le conoce como <b>ingeniería directa</b>.
    </p>

    <h3>Diagramas de clases</h3>
      <p>El diagramad e clases mostraba las calses y los elementos de las mismas, sus atributos y sus métodos. El diagrama mostraba la relación existente entre clases. Java usa precisamente el concepto de clase que tiene implementado.</p>
      <pre><code>
        class Punto {
          protected int posX;
          protected int posY;s

          public Punto (int nuevoX, int nuevoY) {
          posX = nuevoX;
          posY = nuevoY;
          }
        }

        public int darPosX() {
          return posX;
        }

        public int darPosY() {
          return posY;
        }
      </code></pre>
      
      <p>
        Otro aspecto importante del diagrama de clases lo constituyen las relaciones entre clases:
      </p>
      <ul>
        <li><i>Asociación:</i> relación semántica entre dos clases. Se representa con una flecha de cabeza rellena. Hay dos tipos de asociaciones</li>
        <ul>
          <li><i>Unidireccional:</i> relación que indica la navegación en un sentido, es decir, de la clase A a la clase B pero no viceversa. Para representarla, la clase a la que se dirige la asociación, se convierte en variable de instancia de la clase origen</li>
          <li><i>Bidireccional:</i> relación con navegación en ambos sentidos. Son dos relaciones unidireccionales.</li>
        </ul>
        <li><i>Dependencia:</i> es un tipo de relación particular, en la que una clase instanciada va a depender de otra calse. Se representa con una flecha punteada.</li>
        <img src="" alt="$$$ Insertar imagen de asociacion y dependencia $$$">
        <li><i>Herencia:</i> establece vinculos padre-hijo entre clases. Posibilita que una clase sea padre de otra, con lo que la clase hija comparte sus atributos, servicios, etc. Se representa con una línea terminada en un triángulo hueco. En Java emplea la palabra extends.</li>
        <li><i>Agregación:</i> implica a un objeto que está compuesto de otros objetos. También se le conoce como relación parte_de. Se representa con un rombo. Equivale en código a una asociación unidireccional.</li>
        <li><i>Composición:</i> es una relación de agregación más fuerte. Se representa mediante un rombo negro. Equivale en código a una asociación unidireccional.</li>
        <img src="" alt="$$$ Insertar imagen de herencia, agregación y composición $$$">
      </ul>
      
    <h3>Diagramas de interacción</h3>
      <p>
        Existen dos diagramas de interacción: los diagramas de Secuencia y los Diagramas de Colaboración (que en UML 2.0 pasan a llamarse Diagrams de Comunicacionese). En código se representan de la misma forma.
      </p>
      <ul>
        <li><i>Diagramas de Secuencia:</i> muestran los objetos existentes en el escenario y los mensajes que en función del tiempo, se transmiten de uno a otro.</li>
        <li><i>Diagramas de Colaboración:</i> este tipo de diagrama se centra en los objetos. Muestra los roles de cada uno de los objetos y constituye una de las mejores herramientas para identificarlos.</li>
      </ul>
      <img src="" alt="$$$ Insertar imagen de diagramas de interacción $$$">

    <h3>Diagramas de Estado</h3>
      <p>
        Un diagrama de sstado muestra los distintos estados de los que dispone un objeto durante su vida, como se relacionan entre ellos y como responden a determinados eventos. La información que presenten los diagramas de esstado debe reflejarse en los métodos de la clase. Para implementar un evento con condición se utiliza una sentencia IF dentro del evento.
      </p>  
      <img src="" alt="$$$ Insertar imagen de diagrama de estado IF$$$">
      <p>
        Si se quiere implementar la transición entre estados con el mismo evento, se utiliza la sentencia SWITCH CASE.
      </p>
      <img src="" alt="$$$ Insertar imagen de diagrama de estado SWITCH CASE $$$">

    </article>

    <article>
    <h1 id="uml_2">UML 2.0</h1> 
    <h2>Las versiones de UML</h2> 

      <p>
        La primera versión de UML apareció en enero de 1997, y a lo largo de decenas de meses fue variando (la versión 1.1 a finales de ese mismo año a la versión 1.2 en 1998) hasta llegar a una versión con una revisión hecha en profundidad como fue la versión 1.3. Esta versión junto con la 1.4 son las que suelen emplear para realizar diagramas en UML, ya que el paso a la versión 1.5 sólo se incluyeron acciones semánticas que permitieron a UML reconvertirse en un lenguaje de programación?. Y así fue hasta que llegó la versión 2.0 que supuso un acmbio estructural con respecto a las versiones 1.x
      </p>
      <img src="" alt="$$$ Insertar imagen de versiones de UML $$$">

    <h2>Objetivos de UML 2.0</h2>

      <p>
        Las sucesivas revisiones que se le hicieron a UML cometieron el error de permitir que este lenguaje perdiera su identidad. Se agregaron técnicas, se incorporaron diagramas, se hicieron cambios pero lo que realmente ocurrió es que UML se fue convirtiendo en una grupación de técnicas de modelado. Faltaba la coherencia conceptual a la hora de abordar un proyecto.
      </p>
      <p>
        Esta es una de las tareas que intentó abordar la OMG (Object Management Group) una asociación sin ánimo de lucro formada por gigantes de la informática como Sun, IBM, HP o Apple. El mantenimiento de estánderres como CORBA o UML es tarea suya.
      </p>
      <p>
        A la hora de realizar la versión 2.0 se tomaron dos apuntos en consideración:
      </p>
      <ul>
        <li>Los modelos de UML 2.0 deben poder validarse y ejecutarse.</li>
        <li>El lenguaje de modelado debería ser más extensible.</li>
      </ul>
      <p>
        Esto supone una ruptura con respecto a versiones anteriores. En las versiones previas se remarcaba la idea de que UML no era un lenguaje de programación. En UML 2.0 se modificó el lenguaje para que permitiera más compotamiento.
      </p>

    <h2>Reestructuración de UML 2.0</h2>

      <p>Una de las características más interesantes de la versión 2.0 son las cuatro especificaciones en las que se dividió:</p>
      <ul>
        <li>Superestructura</li>
        <li>Infraestructura</li>
        <li>OCL</li>
        <li>XMI</li>
      </ul>
      <p>
        Como UML 2.0 permite definirse a sí mismo, estas cuatro estructuras y su relación pueden modelarse siguiendo el estándar 2.0 tal y como se observa en la siguiente figura:
      </p>
      <img src="" alt="$$$ Insertar imagen de especificaciones UML 2.0 $$$">

      <p>
        Aquí se definen los conceptos de bajo nivel. Esta infraestructura consiste en un meta-modelo empleado para modelar el resto de elementos de UML. De esta extraña definición se desprende que la infraestructura no la utilizan los usuarios finales de UML, los cuales emplean la superestructura, pero proporciona las bases para definirla.
      </p>
      <p>
        En el apartado anterior se comentó que una de las "peticiones" al nuevo lenguaje consistía en su adaptabilidad y extensibilidad. La infraestructura permite que UML sea un lenguaje configurable y parametrizable.
      </p>

      <h3>OCL. Lenguaje de Restricción</h3>
      <p>
        <b>OCL</b> son las siglas de "Lenguaje de Restricción de Objetos" ("Object Constraint Language"). Como indica su nombre, este lenguaje permitirá indicar restricciones sobre los distintos elementos del modelo. Esto es frecuente que ocurra en un dominio concreto ya que los objetos, a veces, sólo pueden tomar unos valores determinados. El lenguaje OCL posibilita la definición de los elementos del modelo de poscondiciones, precondiciones, invariantes, restricciones, etc.
      </p>

      <h3>XMI. Intercambio de Diagramas</h3>
      <p>
        Existen en el mercado multitud de herramientas para modelar UML, pero, en muchos casos, los modelos creados no son compatibles entre ellas. Por este motivo, se utiliza la especificación para el intercambio de diagramas o <b>XMI</b> ("XML Metadata Interchange").
      </p>
      <p>
        En las versiones anteriores existía un formato para compartir datos. Se empleaba un Schema XML que permitía recoger los elementos empleados en el diagrama. Sin embargo este Schema no decía nada sobre el gráfico del modelo. Para solucionarlo XMI emplea un nuevo Schema que utiliza "SVG" ("Scalable Vector Graphics"), un formato de gráficos vectoriales que describe imágenes como formas, trazados, texto y efectos de filtro.
      </p>

      <h3>Superestructura</h3>
      <p>
        Es la definición formal de los elementos UML. Es el conjunto de todos los diagramas que emplean habitualmente los desarrolladores. La estructura de los diagramas de UML y su relación entre ellos se muestran en el siguiente gráfico:
      </p>
      <img src="" alt="$$$ Insertar imagen de superestructura de los diagramas de UML $$$">
      <p>
        Los diagramas se agrupan en tres categorías:
      </p>
      <ul>
        <li><b>Diagramas Estructurales:</b> Diagramas de Clases, Diagramas de Objetos, Diagramas de Pquetes, Diagramas de Componentes, Diagramas de Despliegue y Diagramas de Estructura Compuesta.</li>
        <li><b>Diagramas de Comportamiento:</b> Diagramas de Casos de Uso, Diagramas de Actividades y Diagramas de Estado.</li>
        <li><b>Diagramas de Interacción:</b> Diagramas de Tiempo, Diagramas de Vista de la Interacción, Diagramas de Comunicaciones y Diagramas de Secuencia</li>
      </ul>

    <h2>Diagramas Estructurales</h2>
      <p>
        Focalizan su atención en los elemntos que deben existir en el modelado. Son un total de 6 diagramas:
      </p>
      <ul>
        <li><b>Diagramas de Clases:</b> El principal cambio en este diagrama es la notación lollipop y ball-and-socket. las clases pueden proveer interfaces o necesitarlas (una interfaz especifica las operaciones visibles de forma externa que tiene una clase, componente o paquete). Una clase provee un interfaz si es sustituible por ella (y utiliza un icono en forma de circulo para representarlo). Una clase requiere una interfaz si necesita una instancia de una interfaz para funcionar (y utiliza un ícono en forma de semi-circunferencia)</li>
        <img src="" alt="$$$ Insertar imagen de diagrama de clases UML 2.0 $$$">
        <li><b>Diagramas de Objetos:</b> </li>
        <li><b>Diagramas de Paquetes:</b> </li>
        <li><b>Diagramas de Componentes:</b> El cambio principal es la notación de los componentes. En vez de los dos rectángulos que figuraban a la izquierda se emplea un estereotipo. Además, se emplea el mismo artificio visto en los Diagramas de calses para representar las interfaces requeridas o provistas.</li>
        <li><b>Diagramas de Despliegue:</b> Este diagrama muestra la arquitectura ejecutable del sistema. Los nodos contienen artefactos (artifacts) que son conectados por medio de caminos para crear redes de sistema. En 2.0 se puede, además, representar cualquier elemento empaquetable (como por ejemplo los .jar, .dll, etc.) y añadirles atributos. También se pueden añadir especificaciones de despliegue incluyendo una serie de propiedades que especifiquen como el artefacto será desplegado.</li>
        <li><b>Diagramas de Estructura Compuesta:</b> Una de las novedades más interesantes de la versión 2.0 es la posibilidad de descomponer de forma jerárquica una clase para obtener su estructura interna (incluyendo también los puntos de interacción con otras partes del sistema)</li>
      </ul>
      <p>
        Para dibujarlos emplea tres nuevos elementos:
      </p>
      <ul>
        <li><b>Partes:</b> es una propiedad contenida en un clasificador (como puede ser el caso de una clase). Esto es interesante porque relaciona de forma unívoca esa parte a la clase. Nadie más podrá utilizarla.</li>
        <li><b>Conectores:</b> indican un enlace entre partes, es decir, señala que las partes pueden comunicarse.</li>
        <li><b>Puertos:</b> es un punto de interacción de la clase. Puede tener una interfaz requerida o una interfaz provista.</li>
      </ul>
      <img src="" alt="$$$ Insertar imagen de nuevos elementos de diagramas estructurales? o de estructura compuesta? $$$">

    <h2>Diagramas de Comportamiento</h2>
    <p>
      Enfatizan en los aspectos que deben ocurrir en el sistema modelado.
    </p>
    <ul>
      <li><b>Diagramas de Casos de Uso</b>: En 2.0 los casos de uso pueden representarse como si fueran clases (y para notarlo, debe dibujarse una elipse en la parte superior derecha). Otras dos modificaciones (un poco sosas) serían la posibilidad de incluir notas para describir las relaciones de tipo extends o la utilización de íconos gráficos para describir actores.</li>
      <li><b>Diagramas de Actividades</b>: los cambios realizaros tomaron como idea la posibilidad de emplear una semántica similar a las redes de Petri y que los procesos de negocio tuvieran una representación más fiel. Elementos como las entradas, pin, interrupciones o parámetros se han incorporado a los Diagramas de Actividad. Es una de las áreas que más modificaciones ha sufrido. En UML 1.x los diagramas de actividad eran poco más que casos especiales de los Diagramas de Estado, pero provocaban numerosos problemas. En UML 2.0 se han solucionado y se ha convertido en una de las herramientas más interesantes para modelado de procesos y flujos de trabajo.</li>
      <li><b>Diagramas de Estado</b> </li>
    </ul>

    <h2>Diagramas de Interacción</h2>
      <p>Es uno de los subtipos de los diagramas de comportamiento. Se centran en el flujo de datos y control de los elementos del sistema.</p>
      <ul>
        <li><b>Diagramas de Secuencia</b>: Por poertenecer a esta categoría de diagramas de interacción tienen dos características:</li>
        <ul>
          <li><b>Operadores de interacción</b>: permiten definir opciones, bifurcaciones, rupturas, ejecuciones en paralelo, bucles, etc.</li>
          <li><b>Fragmentos combinados</b>: es una interacción reutilizable. Se le da un nombre al conjunto y posteriormente se puede reutilizar dibujando un rectángulo nombrado con el identificador escogido (tal y como puede observarse en la siguiente figura)</li>
          <img src="" alt="$$$ Insertar imagen de fragmentos combinados $$$">
        </ul>
        <li><b>Diagramas de Tiempo</b>: Recuerdan a los clásicos cronogramas. Muestran los cambios producidos en el estado a lo largo del tiempo (se indican los eventos que se producen y cuando la recepción de una modifica el estado).</li>
        <li><b>Diagramas de Vista de la Interacción</b>: Es uno de los diagramas nuevos de UML 2.0. Consiste en una mezcla de los diagramas de actividades y secuencia. Muestra como interectúan varios diagramas de interacciones.</li>
        <li><b>Diagramas de Comunicaciones</b>: Igual a los diagramas de colaboración en UML 1.X</li>
      </ul>


    </article>

  </div>
</section>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h2>Reference List</h2>
    <ol>
      <li>German Escalante Corpas &amp; Carlos Maza Claver</li>
      <!--li><cite id="refGoFBook"> E. Gamma, et al., Design Patterns: Elements of Reusable Object-Oriented Software. Boston, MA: Addison-Wesley Longman Publishing Co., Inc., 2000.</cite></li-->
    </ol>
  </div>
</section>

<footer id="footerSocialMedia">
  <div class="container">
    <div class="row center-block">
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://www.linkedin.com/in/domingoesteban"><img class="footericon" src="../../images/icons/linkedin2-circle-logo-128.png" alt="Linkedin"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://github.com/domingoesteban"><img class="footericon" src="../../images/icons/github2-circle-logo-128.png" alt="Github"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://twitter.com/domingoesteban"><img class="footericon" src="../../images/icons/twitter2-circle-logo-128.png" alt="Twitter"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://google.com/+DomingoEsteban"><img class="footericon" src="../../images/icons/googleplus2-circle-logo-128.png" alt="Google Plus"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.youtube.com/user/domingoestebanc"><img class="footericon" src="../../images/icons/youtube2-circle-logo-128.png" alt="Youtube"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.facebook.com/domingoesteban"><img class="footericon" src="../../images/icons/facebook2-circle-logo-128.png" alt="Facebook"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://instagram.com/domingoesteban"><img class="footericon" src="../../images/icons/instagram2-circle-logo-128.png" alt="Instagram"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vine.co/domingoesteban"><img class="footericon" src="../../images/icons/vine-circle-logo-128.png" alt="Vine"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vimeo.com/domingoesteban"><img class="footericon" src="../../images/icons/vimeo-circle-logo-128.png" alt="Vimeo"/></a>
      </div>
    </div>
  </div>

  <div class="col-xs-12" id="footerCopyright">
    <h6 class="text-center">Copyright © 2014 Domingo Esteban</h6>
    <!-- <p class="text-center"><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> </p> -->
  </div>

</footer>

<!-- JAVASCRIPT (At the bottom for faster page loading)-->

<!-- jQuery -->
<script src="https://code.jquery.com/jquery.js"></script> <!-- Online version 1 -->
<!--script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script--> <!-- Online version 2 -->

<!-- ARREGLAR!!!! -->
<!--script>window.jQuery || document.write('<script src="includes/js/jquery.js"></script>')</script--> <!-- If no online access 1 -->
<!--script src="includes/js/jquery.js"> </script--> <!-- If no online access 2 -->

<!-- Bootstrap JS -->
<script src="../framework/js/bootstrap.js"> </script>

<!-- Custom JS -->
<script src="../includes/js/scripts.js"></script>

</body>

<!-- PAGINA PARA FORMATO DE REFERENCIAS: http://www.york.ac.uk/integrity/ieee.html -->

</html> 