<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tutorial UML - Domingo Esteban</title>
  <meta name="keywords" content="Domingo, Esteban, Cabala, Robotics, Peru, Spain, Madrid, Arequipa, Unified, Modelling, Language, UML">
  <meta name="description" content="Tutorial UML- Domingo Esteban">
  <meta name="author" content="Domingo Esteban">

  <!-- Mobile viewport optimized -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <!--meta name="viewport" content="width=device-width, initial-scale=1"-->

  <!-- Bootstrap CSS -->
  <!-- <link rel="stylesheet" href="../framework/css/bootstrap.css"> -->
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet'/>
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css' rel='stylesheet'/>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../includes/css/styles.css"/>
  <link rel="stylesheet" href="../../includes/css/tutorials-styles.css"/>

  <!-- Including Modernizr (Before any other Javascript) -->

  <!-- Favicon -->
  <link href="../../images/icons/robot-favicon.ico" rel="icon" type="image/x-icon" />

</head>

<body>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h1 align="center">UML</h1>

    <ul>
    <li><a href="#introduccion">Introducción</a></li>
    <li><a href="#diagramas_estructura_estatica">Diagramas de estructura estática</a></li>
    <li><a href="#diagramas_caso_uso">Diagramas de casos de uso</a></li>
    <li><a href="#diagramas_interaccion">Diagramas de interacción</a></li>
    <li><a href="#diagramas_estado_actividades">Diagramas de estado y actividades</a></li>
    <li><a href="#modelado_fisico">Modelado físico de un sistema</a></li>
    <li><a href="#uml_2">UML 2.0</a></li>
    </ul>
    <article>
    
    <h1 id="introduccion">Introducción</h1>
    
    <p>
      UML (Unified Modelling Language) consiste en un lenguaje que permite documentar, modelar y establecer cualquiera de los elementos que conforman un sistema orientado a objetos.
    </p>

    <p>
      Antes de la existencia de UML, existían distintos métodos y técnicas de orientación a objetos, enfoques variados, muchos problemas de aprendizaje y uso de herramientas, y se carecía de estándares únicos.
    </p>

    <p>
      Combina las metodologías de orientación a objetos de Booch, Rumbaugh y Jacobson.
    </p>

    <p>
      En enero de 1997, se crea la primera versión adoptada como un estándar por el OMG (Object Management Group). Posteriormente, se desarrollaron diversas versiones, y en la actualidad se sigue revisando el estándar.
    </p>
    
    <p>
      Según el <a href="http://www.omg.org">OMG</a>: <b>Unified Modelling Language</b> (<b>UML</b>) es un lenguaje para específicar, visualizar, construir y documentar los elementos de los sistemas software, así como los modelos de negocio y otros sistemas no software.
    </p>

    <p>
      UML cubre las áreas principales que existen a la hora de crear una aplicación orientada a objetos, porque aglutina los principales enfoques de orientación a objetos.
    </p>

    <p>
      Un problema de UML es su falta de integración con otras técnicas como los patrones de diseño o las interfaces de usuario.
      Además, es importante destacar que UML es un lenguaje y no una metodología, por lo que necesita de un proceso de desarrollo, como puede ser <b>RUP</b> (<b>Rational Unified Process</b>) que combina los diagramas de UML con una serie de fases para su realización de un desarrollo software.
    </p>

    <p>
      El éxito de UML, y su aceptación por un amplio procentaje de la industria, se debe a tres motivos principales:
    </p>
      <ul>
        <li>El prestigio de sus tres creadores (Rumbaugh, Jacobson y Booch)</li>
        <li>La lista de potentes empresas que han respaldado UML desde sus inicios.</li>
        <li>La incorpación en un único modelo de las principales ventajas de tres metodologías: OMT, Booch y OOSE.</li>
      </ul>

      <h2>Metodologías orientadas a objetos</h2>

      <p>
        Dentro del campo de la Ingeniería de Software, una metodología está relacionado con un proceso lógico y ordenado que permite producir un programa o software informático.
      </p>

      <p>
        Cada metodología incluye sus propias reglas, técnicas y notaciones predefinidas. Por lo general aportan un algoritmo (conjunto de pasos ordenados) que debe completarse de forma secuencial para conseguir los objetivos. Los ciclos de vida marcan esta secuencialidad.
      </p>

      <p>
        Dentro de los diversos paradigmas del mundo de la informática, el paradigma orientado a objetos consiste en una serie de normas para abordar los problemas. Su base es el mundo real y el concepto es el objeto, que combina estructura de datos y comportamiento en una sola entidad.
      </p>

      <h3>Object Modelling Technique</h3>
        <p>
          OMT o Técnica de Modelado de Objetos consiste en una metodología de Ingeniería de Software para el desarrollo de aplicaciones tomando como paradigma de partida la orientación a objetos. James Rumbaugh es uno de sus autores principales y destacan tres modelos:
        </p>
          <ul>
            <li><b>Modelo de objetos</b>: Contempla aspectos estáticos y proporciona información sobre la estructura de los objetos. Especifíca <i>"a qué le sucede"</i>. Consiste en un diagrama de objetos más un diccionario de datos. El diagrama de objetos muestra las clases y sus relaciones (generalización, agregación, asociación e instancia), mientras que el diccionario de datos representa el detalle de las clases en el diagrama de objetos.</li>
            <li><b>Modelo dinámico</b>: Conjunto de diagramas de estado más un diagrama de flujo de eventos global. Especifíca <i>"cuándo sucede"</i>.</li>
            <li><b>Modelo funcional</b>: Es un diagrama de flujo con restricciones. Especifíca <i>"lo que sucede"</i></li>
          </ul>

        <p>
          Dentro de esta metodología existen tres fases:
        </p>
          <ul>
            <li><b>Análisis</b>: En esta fase se obtiene un modelo preciso, conciso, comprensivo y correcto del mundo real; es decir, se comprende el sistema, se elabora un modelo de resolución y se determina el dominio. En esta fase se obtiene la captura de requisitos. La fase está marcada por tres aspectos: los objetos y sus relaciones, el flujo dinámico de control y las transformaciones funcionales.</li>
            <li><b>Diseño del sistema</b>: Pretende mostrar la arquitectura del sistema: división del sistema en subsistemas, concurrencia, comunicación de subsistemas y almacenamiento de datos.</li>
            <li><b>Diseño de objetos</b>: Pretende refinar y detallar el modelo de análisis, de forma que se pueda construir un modelo que sea cercano a la máquina. El resultado final de esta fase es el documento de diseño, el cual contiene versiones más detalladas de los modelos construidos en el análisis.</li>
          </ul>

      <h3>Object Oriented Design Booch</h3>
        <p>
          El método Booch destaca por sus diagramas, que se utilizan para describir las decisiones de análisis y diseño durante la creación de un sistema orientado a objetos.
        </p>

        <ul>
          <li><b>Diagrama de Clases:</b> Consisten en un conjunto de clases y relaciones entre ellas. Puede contener clases, utilidades, clases paramétricas y metaclases. Los tipos de relaciones son asociaciones, herencia, instancia, contenencia, uso y metaclase.</li>
          <li><b>Especificación de Clases:</b> Usado para capturar toda la información importante acerca de una clase en formato texto.</li>
          <li><b>Diagrama de Categorías:</b> Clases agrupadas de forma lógica bajo diversas categorías.</li>
          <li><b>Diagrama de Transición de Estados:</b> Muestra el comportamiento dinámico del sistema.</li>
          <li><b>Diagrama de Objetos:</b> Muestra objetos en el sistema y su relación lógica. Pueden ser diagramas de escenario, en los cuales se manifiesta la colaboración entre objetos, o diagramas de instancia, que muestran la existencia de los objetos y sus relaciones estructurales entre ellos.</li>
          <li><b>Diagrama de Tiempo:</b> Aumenta el diagrama de objetos con información acerca de eventos externos y tiempod e llegada de los mensajes.</li>
          <li><b>Diagrama de Módulos:</b> Muestra la localización de objetos y clases en los módulos del diseño físico de un sistema. Representa parte o la totalidad de la arquitectura de módulos del sistema.</li>
          <li><b>Subsistemas:</b> Un subsistema es una agrupación de módulos. Es útil en modelos de gran escala.</li>
          <li><b>Diagrama de Procesos:</b> Muestra la localización de los procesos en los distintos procesos de un ambiente distribuido.</li>
        </ul>

        <p>
          Dentro de esta metodología se encuentran tres fases:
        </p>
          <ul>
            <li><b>Análisis de requerimientos</b>: Involucra las funciones primarias del sistema: principales entradas y salidas del sistema, referencias a políticas, sistemas existentes o procedimientos, etc. Además de los mecanismos claves que el sistema debe proveer: estado de entrada, estado de salida y estados esperados.</li>
            <li><b>Análisis de dominio</b>.</li>
            <li><b>Diseño</b>.</li>
          </ul>

      <h2>Ciclo de vida de un sistema</h2>
      <p>
        El ciclo de vida propone un patrón con una serie de pasos y la optimización del resultado final. Adicionalmente, el ciclo de vida indica la forma y la estructuración de los pasos que se dan para realizar un determinado desarrollo software. Estos tres pasos son:
        <ul>
          <li>Análisis. <i>¿Qué se hace?</i></li>
          <li>Diseño. <i>¿Cómo se hace?</i></li>
          <li>Implementación. <i>Programar el sistema</i></li>
        </ul>
      </p>

      <h3>Ciclo de vida en cascada</h3>
        <p>
          El <b>ciclo de vida en cascada</b> es apto para problemas con requisitos bien definidos. Requiere de experiencia en el grupo de desarrollo y conocimientos del entorno y herramientas.
        </p>

        <p>
          Se caracteriza porque cada una de las etapas lleva a otra. Y pueden ser:
        </p>
          <ul>
            <li><b>Ciclo de vida en Cascada Tradicional:</b> Cada etapa necesita finalizarse para pasar a la siguiente. Nunca se vuelve hacia atrás.</li>

            <img src="../../images/tutorials/uml/ciclo_de_vida_cascada.jpg" height="306" width="212" alt="">

            <li><b>Ciclo de vida en Cascada con Mejora Iterativa:</b> A diferencia de la cascada tradicional, es posible una realimentación para revisar la etapa anterior.</li>

            <img src="../../images/tutorials/uml/ciclo_de_vida_cascada_mejora_iterativa.jpg" height="306" width="254" alt="">

          </ul>

      <h3>Ciclo de vida Prototipado</h3>
        <p>
          Se construye un prototipo que sirva como referencia para validad el producto. Existen dos tipos:
        </p>
        <ul>
          <li><b>Desechable:</b> El prototipo se crea a partir de las partes peor definidas y se desecha una vez cumple su función. Es apto cuando la definición del problema no es clara y es poco volátil.</li>

          <img src=".." height="306" width="254" alt="$$$Imagen Ciclo de vida prototipado$$$">

          <li><b>Evolutivo:</b> Apto para problemas mal definidos. Se utiliza un sistema experto en el cual los conocimientos van surgiendo y las necesidades se van incorporando. Reduce el riesgo y aumenta la probabilidad de éxito. Se obtienen versiones rápidas del sistema y el ejemplo más concreto lo constituyen las interfaces de usuario.</li>
        </ul>

      <h3>Ciclo de vida Incremental</h3>

      <p>
        Este ciclo es apto para problemas medianamente definidos. Suele utilizarse en grandes proyectos.
      </p>
      <p>
        Se realiza un ciclo completo (análisis, diseño e implementación), se presenta una versión y con los comentarios obtenidos se realiza un nuevo ciclo para dar una segunda versión.
      </p>

      <img src=".." height="306" width="254" alt="$$$Imagen Ciclo de vida Incremental$$$">


      <h2>Principales Diagramas</h2>

      <p>
        UML propone diferentes diagramas para cubrir gran parte de las áreas de un proceso informático; sin embargo, algunos diagramas no pueden clasificarse de forma concreta dentro del análisis o dentro del diseño ya que seuelen ser versátiles y pueden trabajar en distintas fases.
      </p>

      <p>
        Un <b>diagrama</b> es una perspectiva concreta de una parte de un sistema y su respectiva funcionalidad. Describe lo que hace un sistema pero no cómo se va a implementar.
      </p>

      <p>
        Los principales diagramas existentes son:
      </p>
      <ul>
        <li>Diagrama de Estructura Estática: engloba el Modelo Conceptual y el Diagrama de Clases.</li>
        <li>Diagrama de Objetos</li>
        <li>Diagrama de Casos de Uso</li>
        <li>Diagrama de Interacción: engloba el Diagrama de Secuencia y el Diagrama de Colaboración.</li>
        <li>Diagrama de Estados</li>
        <li>Diagrama de Componentes</li>
        <li>Diagrama de Distribución</li>
        <li>Diagrama de Actividad</li>
      </ul>

      <p>
        En la versión 2.0, se han diseñado nuevos diagramas como por ejemplo el Diagrama de Tiempos. Así mismo, el Diagrama de Colaboraciones pasó a llamarse Diagrama de Comunicaciones.
      </p>

      <h2>Ejemplo UML</h2>

      <ul>
        <li><b>Detalles:</b></li>
        <ul>
          <li>Nombre del Juego: Dardos</li>
          <li>Objetivos: Conseguir más puntos que el rival</li>
          <li>Desarrollo:</li>
          <ul>
            <li>Cada jugador dispondrá de tres dardos y otras tantas tiradas.</li>
            <li>El jugador lanzará los 3 dardos de forma consecutiva contra la diana.</li>
            <li>La zona de impacto proporcionará una puntuación.</li>
            <li>El resultado será la media de los tres lanzamientos</li>
            <li>Hay que prever que alguno de los dardos pueda disponer de algún modificador (por ejemplo el segundo dardo vale el doble)</li>
          </ul>
        </ul>
        <li><b>Diagrama de Casos de Uso:</b></li>
        <ul>
          <li>Este diagrama es una descripción textual (y aveces gráfica) de las distintas acciones que el sistema va a realizar. Constituye una fase muy importante del análisis porque permite pasar de los requisitos que debe cumplir el sistema a una definición más formalizada y concreta de lo que realmente quiere hacerse.</li>
          <li>En el ejemplo, la única acción importante es lanzar el dardo (3 dardos concretamente)</li>
          <li>
            <img src=".." height="306" width="254" alt="$$$Imagen Caso de Uso Dardos$$$">
          </li>
        </ul> 
        <li><b>Modelo Conceptual:</b></li>
        <ul>
          <li>Con este modelo se intenta descubir los conceptos principales, los atributos de los que dispone cada uno y cómo se relacionan entre sí.</li>
          <li>El modelo conceptual es una estructura estática, y modela los elementos del dominio.</li>
          <li>No es una descripción de los objetos del software</li>
          <li>En el ejemplo, el modelo conceptual sería:</li>
          <li>
            <img src=".." height="306" width="254" alt="$$$Imagen Modelo Conceptual Dardos$$$">
          </li>
          <li>Los conceptos importantes son: Jugador, Dardo y Diana.</li>
          <li>Las relaciones entre los conceptos son:</li>
          <ul>
            <li>El Jugador lanza el Dardo.</li>
            <li>El Jugador juega a la Diana.</li>
            <li>El Dardo impacta contra la Diana.</li>
          </ul>
          <li>Los atributos o características de los conceptos son:</li>
          <ul>
            <li>El Jugador tiene como rasgo principal su identificación (nombre).</li>
            <li>La Diana tiene valores (puntuaciones).</li>
            <li>Cada Dardo tiene un orden ya que el enunciado comenta que el orden puede influir en la puntuación.</li>
          </ul>
        </ul>
        <li><b>Diagrama de Secuencia:</b></li>
        <ul>
          <li>En el grupo de Diagramas de Interacción se encunetran los Diagramas de Secuencia. Este diagrama proporciona un gráfico con la secuencia ordenada de los pasos dados y eventos.</li>  
          <li>El diagrama emplea unas líneas verticales para indicar el origen del mensaje (el evento ocurrido) y el destino.</li>
          <li>Debe ser parecdo a un caso real. Si se leen de arriba a abajo los disntinos eventos que figuran encima de cada línea horizontal, se descubre una lectura detallada de todo el proceso.</li>
          <li>En el ejemplo:</li>
          <ul>
            <li>Mediante el mensaje Jugar se inicia el juego.</li>
            <li>Desde la Diana se envía el mensaje Lanzar() al dardo d1.</li>
            <li>El dardo d1 responde a la Diana con el mensaje Impactar().</li>
            <li>Para calcular el valor, la Diana envía el menasje Dar_Valor al área (se asume una simulación de las áreas existentes en las dianas reales). En ese mensaje se incluye la posición de impacto del dardo mediante las coordenadas PosX y PosY.</li>
            <li>Este proceso se repite para los tres dardos.</li>
            <li>Este proceso se repite para los tres dardos</li>
          </ul>
          <li>Se están obviando otras funcionalidades (suma de los tres dardos, puntación acumulada, etc.)</li>
        </ul>
        <li><b>Diagrama de Clases:</b></li>
        <ul>
          <li>Describe las clases y elementos del sistema. Es un complemento indispensable de los diagramas de itneracción. Cualquier pieza que aparezca en el Diagrama de Secuencia debe aparecer en el Diagrama de Clases.</li>
          <li>Este diagrama presenta elementos de la solución software. Al realizarse en la fase de Diseño es un modelo válido para que el programador pueda implementarlo.</li>
          <li>A diferencia del Modelo Conceptual, no se presentan objetos del mundo real. El diagrama presenta elementos informáticos. Se trabaja con clases.</li>
          <li>Para el ejemplo: </li>
          <ul>
            <li>Existe un mensaje Lanzar desde el objeto Diana a cada Dardo. Significa que la clase Dardo incluye ese método.</li>
            <li>Existe un mensaje Impactar desde cada objeto Dardo a cada Diana. Significa que la clase Diana incluye ese método.</li>
            <li>Existe un mensaje Dar_Valor desde el objeto Diana al objeto área. Significa que la clase Áreas incluye ese método.</li>
            <li>Además, se incluyen una serie de atributos (características) dentro de cada clase en base a los parámetros empleados.</li>
            <li>
              <img src=".." height="306" width="254" alt="$$$Imagen Diagrama de Clases Dardos$$$">
            </li>
          </ul>
        </ul>

      </ul>
    </article>

    <article>
    <h1 id="diagramas_estructura_estatica">Diagramas de Estructura Estática</h1>
    <h2>Introducción</h2>
      <p>
        Se engloba dos tipos de diagramas:
      </p>
      <ul>
        <li>Modelo Conceptual: Utilizado en fase de análisis, modela los elementos del dominio.</li>
        <li>Diagrama de Clases: Utilizado en fase de diseño, queda ligado a la solución software y emplea elementos del lenguaje de programación.</li>
      </ul>
      <p>
        Conceptualmente, estos diagramas son distintos pero ambos comparten una notación parecida en los elementos que conforman el sistema, es decir, las clases, los objetos y las relaciones existentes entre ellos.
      </p>

    <h2>Modelo conceptual</h2>
      <p>
        El <b>Modelo conceptual</b> es un diagrama que representa un modelo de los elementos del dominio.
      </p>
      <p>
        Una parte importante para delimitar el dominio del problema es la identificación y posterior tratamientos de los conceptos que lo conforman. Estos conceptos representan elementos del mundo real, no componentes software.
      </p>
      <p>
        Su objetivo es el aumento de la comprensión del problema existente. Por este motivo es interesante buscar el mayor número posible de conceptos.
      </p>

      <h3>Fase I: Identificar los conceptos</h3>
      <p>
        A partir del documento de requisitos y el conocimiento que se tiene del dominio del problema, se identifican los conceptos.
      </p>
      <p>
        Estos conceptos aparecen por medio de la revisión de las categorías relacionadas con el problema (objetos físicos, organizaciones, eventos, transacciones, lugares, etc.) o bien de la lista de sustantivos hallados en los documentos de requisitos.s
      </p>
      <p>
        Entre los tipos de conceptos que se pueden utilizar se encuentran: conceptos abstractos, transacciones, documentación, lugares, protocolos, políticas, reglas, libros, catálogos, roles, especificaciones, organizaciones, archivos, descripciones, otros sistemas, etc.
      </p>

      <h3>Fase II: Crear modelo conceptual</h3>
      <p>
        Se crea un modelo a partir de conceptos obtenidos, las asociaciones (relaciones) entre conceptos y los atributos que se conocen de cada uno.
      </p>
      <ul>
        <li>Las <b>asociaciones</b> son relaciones entre conceptos e indican conexiones entre ambos elementos. Estas relaciones tienen sentido dentro del mundo (del dominio) de los casos de uso. Algunas relaciones típicas pueden ser: A es parte de B, A usa o gestiona B, A es una descripción de B, A posee B, etc.</li>
        <li>Los <b>atributos</b> proporcionan información adicional de los distintos conceptos (características o propiedades) y deben tomar valores simples: un número, un texto, etc. (los tipos complejos se modelarán como conceptos)</li>
      </ul>
      <p>
        Es importante tener en cuenta que no es un concepto definitivo. Es una primera aproximación. Se refinará a lo largo del Análisis y del Diseño (y prácticamente se reconvertirá en el Diagrama de Clases)
      </p>
      <p>Conceptos + Asociaciones + Atributos = Modelo Conceptual</p>

    <h2>Clases, atributos y operaciones</h2>
      <p>
        Una <b>clase</b> es un patrón para definir métodos y atributos que caractericen a un posible objeto.
      </p>
      <p>
        Cualquiera de los objetos creados a partir de una clase es idéntico en forma y en comportamiento, no así en sus características ya que precisamente son sus atributos los que diferencian uno de otro.
      </p>
      <p>
        Una clase se representa mediante una caja rectangular subdividida en tres partes:
      </p>
      <ul>
        <li><i>Parte superior:</i> se indica el nombre de la clase.</li>
        <li><i>Parte media:</i> los atributos de la clase.</li>
        <li><i>Parte inferior:</i> las operaciones.</li>
      </ul>
      <p>
        La clase puede representarse, también, de forma esquemática, con los detalles suprimidos (atributos y operaciones), siendo entonces tan sólo un rectángulo con el nombre de la clase.
      </p>
      <p>
        Una misma clase puede representarse a disntinto nivel de detalle según interese, y según la fase en la que se esté.
      </p>
      <ol>
        <li>La clase "MiClase" plegada (con los detalles suprimidos)</li>
        <li>La clase "MiClase" con detalles a nivel de análisis. Muestra los atributos y los métodos.</li>
        <li>La clase "MiClase" con detalles de implementación. Muestra los atributos y los métodos pero se indica el tipo de cada uno de ellos.</li>
      </ol>
      <img src=".." alt="$$$ Imagen de clase 'MiClase' 1) solo nombre. 2) nombre, atributos y operaciones simple. 3) igual a 2 pero más detallado $$$">
      <p>Ejemplo - Clase punto</p>
      <ul>
        <li>Nombre: Punto</li>
        <li>Atributos: posX, posY</li>
        <li>Métodos: cambiarPosicion(nuevoX, nuevoY), darPosX(), darPosY()</li>
      </ul>
      <img src=".." alt="$$$ Imagen de clase 'Punto' con los 3 niveles de detalle $$$">

    <h2>Objetos</h2>
    <p>
      Los <b>objetos</b> o <b>instancias</b> son entidades atómicas que integran estado y comportamiento.
    </p>
    <p>
      Los objetos incluyen un <b>identificador</b> que les permite, como mínimo, una diferencia a cada uno de los objetos existentes. Este identificador es único y global para cada objeto del sistema.
    </p>
    <p>
      Los objetos se crean a partir de las clases particulizando los atributos existentes.
    </p>
    <p>
      Por ejemplo, a partir de la clase coche se pueden obtener tres objetos con diferente atributo marca: Toyota, BMW y Renault.
    </p>
    <p>
      Los objetos tienen la misma representación que las clases pero con dos particularidades:
    </p>
    <ul>
      <li>Los atributos se conretan para el objeto en cuestión.</li>
      <li>En la parte superior aparece el nombre del objeto junto con el nombre de la clase (subrayados), siguiendo la sintaxis: <code>nombre_del_objeto:nombre_de_la_clase</code>.</li>
    </ul>
    <img src=".." alt="$$$ Imagen de los objetos 'p1:Punto' y 'p2:Punto' $$$">


    <h2>Diagrama de Clases</h2>
      <p>
        El <b>diagrama de clases</b> permite visuallizar las clases existentes en la aplicación y las relaciones entre éstas.
      </p>
      <p>
        Los elementos (y los conceptos necesarios) que componen el Diagrama de Clases son:
      </p>
      <ul>
        <li><i>Clase:</i> atributos, métodos y visibilidad.</li>
        <li><i>Relaciones:</i> herencia, composición, agregación y asociación.</li>
      </ul>

      <h3>Clases</h3>
        <p>
          La <b>clase</b> es la unidad básica que encapsula toda la información de un Objeto. La clase se representa por un rectángulo con tres divisiones:
        </p>
        <img src=".." alt="$$$Rectangulo con tres divisiones: 'nombre Clase', 'Atributos' y 'Métodos'$$$">
        <p>
          Las clases se componen de atributos (información o propiedad inherente a todos los objetos de la clase) y operaciones o métodos (funciones proporcionadas por la clase). 
        </p>
        <p>
          Las clases se identifican de forma "TOP-DOWN", es decir, de los elementos generales a los elementos particulares.
        </p>
        <p>
          Las clases son los elementos físicos y lógicos dentro del sistema.
        </p>
        <p>
          Cada clase define el ámbito de definición de un conjunto de objetos (las instanciaciones de las propias clases).
        </p>

      <h3>Atributos</h3>
        <p>
          Se trata de localizar las características que determinarán las diferencian entre un objeto y otro. Por ejemplo, en la clase Persona se necesita del atributo DNI que permita identificarlo de forma única.
        </p>
        <p>
          Los atributos, características o propiedades de una Clase puedens er de tres tipos, dependiendo del grado de comunicación y visibilidad de ellos con el sistema:
        </p>
        <ul>
          <li><b>public:</b> Se denotan con el símbolo <b>(+)</b>, e indica que el atributo será visible tanto dentro como fuera de la clase. Este atributo es accesible desde cualquier punto.</li>
          <li><b>private:</b> Se denotan con el símbolo <b>(-)</b>, e indica que el atributo sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden acceder a él.</li>
          <li><b>protected:</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el atributo no es accesible desde fuera de la clase, pero, si es heredado, los métodos de la clase y las subclases pueden acceder a él.</b></li>
        </ul>

      <h3>Métodos</h3>
        <p>
          Los métodos de una clase constituyen la única forma de interacción entre los distintos objetos.
        </p>
        <p>
          Si se implementan de forma correcta los principios de <b>encapsulación</b>, los métodos son los elementos que acceden a cada uno de los atributos.
        </p>
        <p>
          Los métodos pueden tener estas visibilidades:
        </p>
        <ul>
          <li><b>public:</b> Se denotan con el símbolo <b>(+)</b>, e indica que el método será visible tanto dentro como fuera de la clase. Este método es accesible desde cualquier punto.</li>
          <li><b>private:</b> Se denotan con el símbolo <b>(-)</b>, e indica que el método sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden hacer uso de él.</li>
          <li><b>protected:</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el método no es accesible desde fuera de la clase, pero, si es heredado, otros métodos de la clase y las subclases pueden ser usados.</b></li>
        </ul>
        <p>
          El conjunto de métodos de una clase se denomina <b>protocolo</b> de la case.
        </p>
        <p>
          Por ejemplo, en una cuenta bancaria:
        </p>
        <ul>
          <li>Atributos:</li>
          <ul>
            <li>-numeroCuenta : int &#8594; Un número que identifica la cuenta.</li>
            <li>-balance: int &#8594; Muestra la cantidad de dinero depositada.</li>
          </ul>
          <li>Métodos:</li>
          <ul>
            <li>+balance() : int &#8594; Devuelve la cantidad existente en el depósito.</li>
            <li>+ingresar(entrada cantidad : int) : void &#8594; Ingresa la cantidad especificada aumentando el valor del atributo balance.</li>
            <li>+pago(entrada cantidad : int) : bool &#8594; Indica si la operación de pago ha sido positiva (TRUE) o negativa (FALSE)</li>
          </ul>
        </ul>
        <img src="" alt="$$$Insertar imagen Clase 'CuentaBanco' $$$">

        <p>
          Pasos para realizar un Diagrama de Clases
        </p>
        <ul>
          <li>Identificar las clases a partir de los Diagramas de Interacción.</li>
          <li>Colocar las clases en el Diagrama.</li>
          <li>Insertar los atributos obtenidos en el Diagrama Conceptual.</li>
          <li>Insertar los atributos obtenidos en los Diagramas de Interacción.</li>
          <li>Dar a cada método o atributo un tipo.</li>
          <li>Indicar las asociaciones entre clases.</li>
        </ul>


    <h2>Modelado de relaciones</h2>
      <p>
        Las asociaciones entre dos clases se representan mediante una línea gráfica entre ellas. Esta línea incluirá una serie de elementos gráficos que indican el tipo de asociación.
      </p>
      <p>
        El nombre de la asociación es opcional, pero debe expresarse en aquellos casos en los cuales no se entienda bien la relación entre las clases. El nombre de la relación se indica con un texto próximo a la línea.
      </p>
      <p>
        Se puede añadir, además, un pequeño triángulo de color negro para indicar la dirección en la cual leer el nombre de la asociación (una relación puede ser 'A es hijo de B' pero también valdría 'B es padre de A')
      </p>
      <p>
        La semántica de las relaciones dependerá de los objetos. Ellos darán significado a la relación.
      </p>
      <p>
        Por ejemplo pueden existir las relaciones: Un objeto de la clase Conductor conduce un objeto de la clase Coche; un objeto de la clase Perro es mascota de un objeto de la clase Persona.
      </p>
      <img src="" alt="$$$ Imagen de Relaciones Conductor-Coche Perro-Persona $$$">
      <p>
        El hecho de incluir nombres sólo afecta a la legibilidad del modelo, pero hay que utilizarse con discreción, porque si es demasiado abundante la información presentada, existe el consiguiente riesgo de saturación de información.s
      </p>

      <h3>Multiplicidad</h3>
        <p>
          La <b>multiplicidad</b> constituye una restricción que se pone a una asociación ya que indica el número de instancias de una clase que pueden tener esa asociación con una instancia de la otra clase.
        </p>
        <p>
          El decir que se indica el número de instancias, involucra que se limita el número de clases. Por ejemplo, un hijo tiene sólo un padre, pero un padre puede tener de 0 a n hijos.
        </p>
        <p>
          La multiplicidad se expresa de cualquiera de estas formas:
        </p>
        <ul>
          <li><b>1</b> &#8594; Uno y sólo uno</li>
          <li><b>0..1</b> &#8594; Cero o uno</li>
          <li><b>M..N</b> &#8594; De M a N (sólo enteros positivos)</li>
          <li><b>*</b> &#8594; De cero a varios</li>
          <li><b>0..*</b> &#8594; De cero a varios</li>
          <li><b>1..*</b> &#8594; De uno a varios</li>
        </ul>
        <p>
          La multiplicidad se indica en el Diagrama colocando a ambos lados de la línea al número de instancias.
        </p>
        <p>En el primer caso el abuelo puede tener desde un nieto hasta N (como mínimo debe tener un nieto porque sino no tendría sentido el rol de abuelo). Un nieto puede tener 4 abuelos (no se considera si están vivos o no)</p>
        <p>En el segundo caso, la familia puede tener dsde 0 a N mascotas. Sin embargo la mascota puede pertenecer a una sola familia.</p>
        <img src="" alt="$$$ Imagen Multiplicidad Abuelo-nuetos y gato-familia $$$">

      <h3>Roles</h3>
        <p>
          Los <b>roles</b> pueden utilizarse para indicar el papel que juega una clase en una asociación. Se colocan en cada uno de los extremos de la asociación junto a la clase que desempeña dicho rol. Así mismo, describe una semántica teniendo siempre en cuenta el sentido escogido.
        </p>
        <p>
          En el ejemplo siguiente, se expresa una relación paternal con los dos roles implicados. Además, en este caso, las clases son iguales. El rol marcará lo que se incluya en cada clase y lo que se guarde en la base de datos.
        </p>
        <img src="" alt="$$$ Imagen Roles clase Persona y los roles padre/hijo $$$">

      <h3>Relación de Agregación</h3>
        <p>
          La <b>agregación</b> o <b>parte_de</b> es una relación que implica a un objeto que está compuesto por otros objetos. Es un tipo de relación dinámica en la cual la duración del objeto incluido es independiente del objeto que lo incluye (por ejemplo, una rueda puede existir sin que esté la clase coche).
        </p>
        <p>
          La clase agregación se representa con un ícono transparente en forma de diamente colocado en el extremo en el que está la clase que representa la parte genérica. En el ejemplo, la clase coche podría formarse a partir de las clases Motor, Chasis, Ruedas e Interior.
        </p>
        <img src="" alt="$$$ Imagen Relación de agregación Coche-(Chasis,Ruedas,Motor,Interior) $$$">

      <h3>Relación de Asociación</h3>
        <p>
          La <b>asociación</b> expresa una relación semántica bidireccional entre dos clases. Si una asociación tiene propiedades privativas, se representa como una clase unida a la línea de asociación por medio de una línea punteada.
        </p>
        <p>
          La asociación entre clases permite relacionar objetos que colaboran entre sí, pero no es una relación fuerte, es decir, el tiempo de vida de un objeto no depende del otro. Esta característica existe también en la agregación, esto debido a que la <i>Agregación es un caso particular de Asociación</i>.
        </p>
        <p>
          En el ejemplo siguiente se muestra una relación de asociación y la modificación a realizar cuando la relación tiene atributos.
        </p>
        <img src="" alt="$$$ Imagen Asociacion Persona-Empresa con atributo salario $$$">

      <h3>Asociaciones n-arias</h3>
        <p>
          En las relaciones n-arias participan más de dos clases y se representan mediante un rombo central que une con líneas todas las clases.
        </p>
        <p>
          Si en un rol determinado se muestra la multiplicidad, ésta indicará el número potencial de tuplas de instancias en la asociación cuando el resto de valores sean fijos.
        </p>
        <p>
          En el ejemplo siguiente, se muestran 3 clases pero es la clase ciclista la que marca el sentido: puede correr N vueltas en un año, sólo puede estar en un equipo, etc.
        </p>
        <img src="" alt="$$$ Imagen Asociacion n-aria Ciclista-Vueltas-Equipo $$$">

      <h3>Relación de Herencia</h3>
        <p>
          La <b>relación de herencia</b> establece vínculos padre-hijo entre clases. Posibilita que una clase sea padre de otra, con lo que la clase hija comparte sus atributos, servicios, etc.
        </p>
        <p>
          La herencia es una relación <i>B es un A</i>. Permite que una <b>subclase</b> herede los métidos y atributos especificados por una <b>Super Clase</b>. En otras palabras, la subclase dispondrá de los métodos y atributos de la calse padre, y además poseerá sus propios métodos y atributos.
        </p>
        <p>
          La relación de herencia se representa con una línea contínua terminada en un triángulo en el extremo de la relación que corresponde a la clase más general o clase "padre".
        </p>
        <p>
          En el ejemplo siguiente, aparecen las clases Coche y Camion que heredan de la clase Vehículo. La clase Coche dispondrá de los atributos y métodos de Vehículo y, además, incorpora dos atributos como son ocupantes y capota. En el caso de la clase Camión también hereda atributos y métodos de Vehículo pero incorpora dos atributos como son la Tara y la Carga. La herencia permitirá tanto a la clase coche como camión, emplear las clases y atributos de Vehículo sin tener que declararlas.
        </p>
        <img src="" alt="$$$ Imagen Herencia Vehículo-(Coche,Camión) $$$">
        <p>
          En algunos casos, el número de clases que heredan es excesivo y no hay sitio para representarlas. Si ocurre este proble se pueden emplear puntos suspensivos.
        </p>
        <img src="" alt="$$$ Imagen Herencia Departamentos-(RRHH,Direccion,Tecnologia,...) $$$">

      <h3>Relación de Dependencia (o uso)</h3>
        <p>
          La <b>Relación de Dependencia (o uso) </b> se utiliza para mostrar una dependencia de una clase hacia otra. Se utiliza una línea punteada direccional que indique el sentido de la dependencia para mostrarlo de forma gráfica.
        </p>
        <p>
          Es una <i>relación semántica</i> entre dos elementos del modelo. Indica que los cambios realizados en la clase independiente pueden demandar cambios en las clases dependientes.
        </p>
        <p>
          En el ejemplo siguiente, la clase Ventana depende de la clase InterfazGrafica (la creación de objetos de clase Ventana se han condicionado a la instanciación provenientes desde la clase InterfazGrafica)
        </p>
        <img src="" alt="$$$ Imagen Relacion de Dependencia InterfazGrafica-Ventana $$$">


    <h2>Visibilidad y alcance</h2>
      <p>
        El concepto de <b>visibilidad</b> se atribute a los atributos y los métodos. Indica la posibilidad de que estos elementos puedan ser utilizados por otras clases.
      </p>
      <ul>
        <li><b>public (o públicos):</b> Se denotan con el símbolo <b>(+)</b>, e indica que el atributo o método será visible (y por lo tanto puede utilizarse) tanto dentro como fuera de la clase.</li>
        <li><b>private (o privados):</b> Se denotan con el símbolo <b>(-)</b>, e indica que el atributo o método sólo es accesible desde dentro de la propia clase. Los métodos de la clase son los únicos que pueden acceder a él.</li>
        <li><b>protected (o protegidos):</b> Se denotan con el símbolo <b>(#), y constituye un tipo intermedio porque indica que el atributo o método no es accesible desde fuera de la clase, pero, si es heredado, los métodos de slas subclases pueden acceder.</b></li>
      </ul>
      <p>
        Se emplea esta técnica para proteger los datos de cualquier tipo de acceso no permitido.
      </p>
      <p>
        En el ejemplo siguiente, los atributos puertas y ruedas son protegidos mientras que el atributo velocidad es privado. El atributo marca es público.
      </p>
      <img src="" alt="$$$ Imagen clase 'Vehículo' $$$">

    </article>

    <article>
    <h1 id="diagramas_caso_uso">Diagramas de Casos de Uso</h1>

    <h2>Requisitos del sistema</h2>
      <p>
        El análisis de un sistema empieza siempre con la especificación de requisitos. Un <b>requisito</b> es una descripción de las necesidades que plantea el sistema. Por lo tanto, el objetivo de esta educción de requisitos es la identificación de las peticiones realizadas por el cliente para poder transmitirlas al equipo de desarrollo.
      </p>
      <p>
        Los puntos principales que hay que analizar en esta fase son:
      </p>
      <ul>
        <li>Funcionalidad del sistema</li>
        <li>Ámbito de actuación</li>
        <li>Objetivos</li>
        <li>Atributos y propiedades del sistema</li>
      </ul>

    <h2>Diagramas de Casos de Uso</h2>
      <p>
        El documento de especificación de requisitos comentado anteriormente, no viene incluido en la notación UML, pero los casos de uso constituyen una buena aportación para mejorar la comprensión de los requisitos y su posterior refinación.
      </p>
      <p>
        Los casos de uso son diagramas que establecen una idea dinámica y determinan como el sistema y las clases cambian con el tiempo.
      </p>
      <p>
        Un <b>diagrama de Casos de Uso</b> muestra las distintas operaciones que se esperan de una aplicación o sistema y cómo se relaciona con su entorno (usuarios u otras aplicaciones). Por lo tanto, los casos de uso se parecen a las especificaciones funcionales.
      </p>
      <p>
        Para construir un diagrama de caso de uso, se necesita unos actores, los casos de uso a considerar y las relaciones existentes entre ambos.
      </p>

    <h2>Casos de Uso</h2>
      <p>
        Los casos de uso representarán las tareas y responsabilidades de cada uno de los actores. Es una narración (en lenguaje natural) para describir la secuencia de interacciones entre un actor y el sistema.
      </p>
      <p>
        Fueron creados por Ivar Jacobson y cubren las carencias de modelos (OMT y Booch) en cuanto a la determinación de requisitos.
      </p>
      <p>
        Los casos de uso permiten encontrar los límites de sistema. Deben ser siempre simples, inteligibles, claros y concisos.
      </p>
      <p>
        Para representarlos de forma gráfica se utilizan elipses acompañadas de un nombre significativo que indique un proceso concreto. Cada caso de uso constituye una operación completa.
      </p>
      <p>
        Un aspecto a tener en cuenta es el nivel de abstracción que tienen los casos de uso. En primera instancia conviene crear casos de uso de Alto Nivel (desde su nivel de abastracción más alto). En estos casos de uso la descripción es muy general, con pocas frases. Por tanto su objetivo se centra en adquirir nociones del ámbito y de la complejidad del sistema.
      </p>
      <p>
        Los casos de uso que más influyan en el resto y en general, los casos más importantes, se explotarán en un nuevo nivel de detalle, dando lugar a los casos de Uso Expandidos.
      </p>
      <p>
        En el ejemplo se observa como el Caso de uso Hacer Declaracion de la Renta puede a su vez subdividirse en otros niveles que maticen el modelo con el que se está trabajando.
      </p>
      <img src="" alt="$$$ Imagen casos de uso 'Hacer Declaracion de la Renta' $$$">

      <p>
        Para encontrar casos de uso se puede realizar un proceso de brainstorming dentro del grupo de desarrollo o análisis, tomando como referencia preguntas del estilo:
      </p>
      <ul>
        <li>¿Cuáles son las operaciones más importantes del sistema?</li>
        <li>¿Cuáles son las principales tareas y responsabilidades de un actor?</li>
        <li>¿Qué datos posee el actor para consultar, actualizar, modificar o borrar?</li>
        <li>¿Qué cambios externos debe informar al sistema? ¿Son necesarios?</li>
        <li>¿Qué casos de uso crearán, borrarán, consultarán o modificarán?</li>
        <li>¿Qué información ncesita el actor de parte del sistema?</li>
        <li>¿Qué casos de uso dan soporte y mantendrán el sistema?</li>
      </ul>

      <p>
        Si bien no existen normas escritas para el desarrollo de casos de uso, se suelen seguir las siguientes pautas:
      </p>
      <ul>
        <li>Los casos de uso no utilizan lenguaje real. Por ejemplo si se realiza un caso de uso para operar con un cajero, se emplea la palabra código no PIN. A posteriori se puede revisar el caso de uso y adaptarlo.</li>
        <li>Conviene crear al principio casos de uso de alta nivel (más genéricos) e irlos refinando.</li>
        <li>El nombre de los casos de uso debería ser un verbo. De esta forma se acentúa la idea de estar trabajando con procesos.</li>
      </ul>
      <p>
        Los casos de uso se describen de forma gráfica y/o textual. Si se opta por el formato texto, se puede seguir el siguiente guión:
      </p>
      <ul>
        <li>Nombre Caso de Uso</li>
        <li>Objetivo</li>
        <li>Actores implicados</li>
        <li>Descripción</li>
        <li>Secuencia de acciones</li>
      </ul>
      <p>
        Por ejemplo si se desea realizar los casos de uso de un cajero automático, se deben detallar los pasos a realizar el cliente para poder realizar un reintegro y retirar dinero del cajero.
      </p>
      <ul>
        <li>Caso de Uso: Cajero Automático (Reintegro)</li>
        <li>Objetivo: Desarrollar una operación de reintegro en un cajero.</li>
        <li>Actores: Cliente, Cajero</li>
        <li>Descripción: El cliente llega al cajero. Inserta su tarjeta en la correspondiente ranura y marca su identificación personal. Del menú de opciones ofrecido, el cliente elige reintegro. Indica la cantidad que va a retirar. El cajero comprueba que existe dinero en la cuenta asociada y si es así, proporciona al cliente el dinero y le devuelve la tarjeta. El cliente se va.</li>
      </ul>
      <p>Secuencia de acciones:</p>
      <table style="width:100%">
        <tr>
          <td>CLIENTE</td>
          <td>SISTEMA DEL CAJERO</td>
        </tr>
        <tr>
          <td>(1) El cliente inserta la tarjeta</td> 
          <td></td>
        </tr>
        <tr>
          <td></td>    
          <td>(2) Pide la identificación</td>
        </tr>
        <tr>
          <td>(3) Teclea la contraseña</td>    
          <td></td>
        </tr>
        <tr>
          <td></td>    
          <td>(4) Muestra el menú de opciones</td>
        </tr>
        <tr>
          <td>(5) Selecciona la operación "Reintegro"</td>    
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>(6) Pregunta la cantidad</td>
        </tr>
        <tr>
          <td>(7) Escribe la cantidad necesaria</td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td>(8) Procesar la operación</td>
        </tr>
        <tr>
          <td></td>
          <td>(9) Emitir recibo. Devolver tarjeta. Dar dinero</td>
        </tr>
        <tr>
          <td>(10) Recoger tarjeta, recibo y dinero.</td>
          <td></td>
        </tr>
      </table>

      <p>
        En el caso anterior, no se ha simulado la existencia de problema. De ser así habría que indicar las secuencias alternativas.
      </p>
      <ul>
        <li>En el caso (4) Muestra el menú de opciones, si la contrasela no es correcta se marca el error y se pude una nueva clave (hasta un máximo de tres)</li>
        <li>Para el caso (8) Procesar la operación puede ocurrir que la cantidad reclamada sea superior al saldo de la cuenta asociada. Habrá que indicar el error y pedir una cantidad menor.</li>
      </ul>

    <h2>Actores</h2>
      <p>
        Representan a los agentes que interactúan con el sistema. Por tanto, no forman parte del sistema pero si lo introducen y/o reciben información de él.
      </p>
      <p>
        Los actores se representan con un símbolo esquemático seguido de un nombre que sea significativo (siempre y cuando fuera necesario).
      </p>
      <p>
        Una misma persona física puede desempeñar varios papeles de actor. Existen varias categorías:
      </p>
      <ul>
        <li><b>Principales:</b> personas que utilizan el sistema.</li>
        <li><b>Secundarios:</b> administradores del sistema.</li>
        <li><b>Externos:</b> dispositivos materiales que deben utilizarse en el sistema.</li>
        <li><b>Otros sistemas:</b> sistemas que interactúan.</li>
      </ul>
      <p>
        Para encontrar los actores se pueden realizar las siguientes preguntas:
      </p>
      <ul>
        <li>¿Se puede identificar a los usuarios del sistema?</li>
        <li>¿Quién está interesado en un requirimiento concreto?</li>
        <li>¿Quién proporciona o recibe información del sistema?</li>
        <li>¿Algún agente dispone de varios roles?</li>
        <li>¿Quién da soporte al sistema? ¿Quién administra?</li>
        <li>¿Quiénes interactúan de forma directa con el sistema?</li>
        <li>¿Hay sistemas con los cuales se comunica?</li>
        <li>¿Cuál es el dominio del sistema?</li>
        <li>¿Se utilizan recursos externos?</li>
      </ul>
      <p>
        Los actores varían dependiendo del enterno en el que se sitúe el problema y la parte del mismo que se aborde.
      </p>
      <p>
        Por ejemplo, si se modela un sistema relativo a un centro de formación o academia. Los posibles actores que entrarían en juego serían:
      </p>
      <ul>
        <li>Actores para sistema de formación</li>
          <ul>
            <li>Profesores: los que imparten clases.</li>
            <li>Alumnos: personas matriculadas.</li>
            <li>Secretaria: persona que recibe al alumno a diario y tramita sus dudas.</li>
            <li></li>
          </ul>
        <li>Actores para sistema de ventas</li>
          <ul>
            <li>Cliente: potencial alumno.</li>
            <li>Comercial: persona que vende el curso.</li>
            <li>Jefe de comerciales: coordina a los comerciales y sus ventas.</li>
            <li>Secretaría: persona que matricula al alumno.</li>
          </ul>
      </ul>

    <h2>Relaciones</h2>
      <p>
        Las <b>relaciones</b> son las interacciones existentes entre actores y casos de uso o entre dos casos de uso. Se representan con una línea dirigida desde el elemento dependiente del elemento independiente y una etiqueta (&lt;).
      </p>
      <img src="" alt="$$$ Imagen relaciones reciclar y generar_informe $$$">

      <p>
        Existen tres tipos de relaciones:
      </p>
      <ul>
        <li><b>Comunica (communicates)</b>: Relación existente entre un actor y un caso de uso. Denota la participación del actor en el caso de uso determinado. Normalmente no se indica ya que las relaciones existentes entre el actor y el caso de uso son de este tipo.</li>
        <li><b>Usa (uses) (includes)</b>: Relación existente entre dos casos de uso. Denota la inclusión del comportamiento de un escenario en otro. Se marca con la notación <i>uses</i>. Desde UML 1.3 se especifica como includes.</li>
        <li><b>Extiende (extends)</b>: Relación existente entre dos casos de uso. Se produce cuando un caso de uso constituye una especialización de otro. Es un concepto similar a la herencia. Se marcan con la notación <i>extends</i>.</li>
        <li><b>Generalización (generalization)</b>: La descripción de un actor puede matizarse mediante esta asociación. Conceptualmente es similar al concepto de herencia de clases.</li>
      </ul>
      <p>
        Para detectar relaciones se puede realizar las siguientes preguntas:
      </p>
      <ul>
        <li><i>Relaciones communicates:</i> ¿En qué casos de uso se ve envuelto un actor?</li>
        <li><i>Relaciones extends:</i> ¿Qué casos de uso son similares? ¿Cuáles de ellos se diferencian en la forma de realizar y ejecutar la operación? ¿Qué casos redefinen la forma en la cual se realiza una transacción dentro de otro caso de uso?</li>
        <li><i>Relaciones uses:</i> ¿Qué casos se emplean como transiciones de otros? ¿en qué casos de uso se puede englobar un caso concreto?</li>
      </ul>


    <h2>Construcción del diagrama de Casos de Uso</h2>
      <p>
        Los pasos que pueden seguirse para construir un modelo de casos de uso durante la fase de análisis del problema son:
      </p>
      <ul>
        <li>Listar funciones del sistema y límites.</li>
        <li>Identificar actores.</li>
        <li>Indentificar casos de uso. Escribirlos.</li>
        <li>Realizar el diagrama de casos de uso.</li>
        <li>Indicar todas las relaciones existentes dentro del diagrama.</li>
        <li>Expandir y detallar los casos de uso más importantes.</li>
        <li>Crear casos de uso reales si fuera necesario.</li>
      </ul>

    </article>

    <article>
    <h1 id="diagramas_interaccion">Diagramas de Interaccion</h1>
    <h2>Interacción</h2>
      <p>
        Un <b>escenario</b> describe la ejecución de un caso de uso a partir de las interacciones existentes entre los objetos. Un escenario es una instancia del caso de uso, es decir, muestra una ejecución real de un caso de uso planteando las distintas posibilidades, bifurcaciones y alternativas propuestas por el caso de uso pero adaptadas a unos valores concretos.
      </p>
      <p>
        Los <b>diagramas de interacción</b> permiten describir los escenarios. Pueden utilizarse dos tipos:
      </p>
      <ul>
        <li><i>Diagramas de Secuencia</i>: relacionan la interacción entre objetos con el tiempo de ejecución.</li>
        <li><i>Diagramas de Colaboración</i> (en UML 2.0, <i>Diagramas de Comunicación</i>): se centran en las relaciones entre objetos.</li>
      </ul>

    <h2>Diagramas de Secuencia</h2>
      <p>
        Un <b>diagrama de secuencia</b> muestra una secuencia cronológica de mensajes durante un escenario concreto, es decir, una secuencia ordenada de eventos.
      </p>
      <p>
        Los elementos que entran en juego en un diagrama de secuencia son:
      </p>
      <ul>
        <li><b>Objeto:</b> los objetos o actores se colocan en la parte superior (de izquierda a derecha) del diagrama sin un orden prefijado. Cada uno dispone de una línea vertical denominada <b>línea de vida</b>. Las características que marcan esta línea son:</li>
        <ul>
          <li>Es una línea discontínua.</li>
          <li>Los mensajes parten de una línea y van a otra.</li>
          <li>Los recuadros que aparecen sobre las líneas de la vida marcan la duración de una determinada operación y se denominan zona de activación.</li>
        </ul>
        <img src="" alt="$$$ Imagen objetos y línea de vida$$$">
        <li><b>Mensaje:</b> es la información o aviso intercambiado entre dos objetos. Se representa con una flecha que va desde una línea de vida a otra. Estos mensajes pueden ser:</li>
        <ul>
          <li><b>Asincrónico:</b> el envío de un mensaje asincrónico implica que no se necesita una respuesta para continuar la ejecución. En UML y las versiones se muestra como una flecha con media cabeza, a partir de UML 1.4 se dibuja como una flecha con la cabeza abierta.</li>
          <li><b>Sincrónico:</b> es necesario, para su correcto funcionamiento, esperar la respuesta al mensaje que se ha enviado antes de seguir con la ejecución.</li>
          <li><b>Simple:</b> transferencia básica de información y del control de un objeto a otro.</li>
        </ul>
        <img src="" alt="$$$ Imagen tipos de mensajes $$$">
        <li><b>Tiempo:</b> el tiempo se representa mediante el eje vertical. La parte superior del diagrama será el punto de partida, por tanto si un mensaje está más cerca de la parte inferior que otro, significa que ha ocurrido más tarde. En la siguiente imagen se observa los mensajes escalonados, lo que hace que dependan cronológicamente hablando de otros.</li>
        <img src="" alt="$$$ Imagen mensajes escalonados $$$">
      </ul>
      <p>
        Por ejemplo, para el diagrama de secuencia de una llamada telefónica se tiene:
      </p>
      <ul>
        <li>Objetos: persona que llama (emisor), persona que recibe la llamada (receptor) y la propia línea telefónica.</li>
        <li>Pasos:</li>
        <ul>
          <li>Emisor descuelga el teléfono.</li>
          <li>El teléfono le da línea.</li>
          <li>El emisor marca el número de teléfono.</li>
          <li>La línea telefónica manda un aviso al receptor, y, a la persona que llama, se le manda un tono de llamada en proceso.</li>
          <li>Si el receptor está, descuelga el teléfono.</li>
          <li>El receptor inicia la conversación con el emisor.</li>
        </ul>
      </ul>
      <img src="" alt="$$$ Imagen de diagrama de secuencia de llamada telefónica $$$">
      
      <p>
        El control que se traslada de un objeto a otro en los diagramas de interacción son de dos tipos:
      </p>
      <ul>
        <li><b>Control centralizado:</b> desde una línea de vida se mandan los mensajes a las otras líneas de vida.</li>
        <li><b>Control descentralizado:</b> cuando una línea de vida envía un mensaje, cede el control a esa nueva línea de vida.</li>
      </ul>
      <img src="" alt="$$$ Imagen de tipos de control en diagrama de secuencia $$$">

      <p>
        Para cada uno de los casos de uso existentes, debe realizarse un diagrama de secuencia que muestre el desarrollo normal de acciones. Además, se creará otro diagrama para las alternativas y bifurcaciones (aunque en algunos casos pueden integrarse en un único diagrama).
      </p>
      <p>
        Los objetos también pueden destruirse. El hecho de colocar un objeto en pantalla con su línea de vida, implica que ese objeto se ha creado. Si en su línea de vida se incluye un ícono de forma de aspa, significa que el ese punto temporal el objeto se ha destruido (en UML 2.0, el elemento que tiene la línea de vida no tiene porque ser un objeto -y no debería ser subrayado)
      </p>
      <img src="" alt="$$$ Imagen de diagrama de secuencia creación y destrucción de objeto $$$">


    <h2>Estructuras de los Diagramas de Secuencia</h2>
      <p>
        Existen varios tipos de estructuras:
      </p>
      <ul>
        <li><b>Secuenciales:</b> para representar una serie de acciones que se realizan de forma continuada (es decir, separadas por un margen de tiempo) se lanzan los mensajes desde una línea de vida separados por un lapso de tiempo.</li>
        <img src="" alt="$$$ Diagrama de secuencia con estructura secuencial $$$">
        <li><b>Reflexivas (o recursiva):</b> Un objeto puede enviarse mensajes a sí mismo, es decir, se invoca a sí mismo.</li>
        <img src="" alt="$$$ Diagrama de secuencia con estructura reflexiva $$$">
        <li><b>Condicionales:</b> cuando se necesita realizar una estructura condicional (if-then-else) se emplea una estructura similar a la figura, indicando tantos mensajes como condiciones existan. El mensaje se envía si se cumple esa condición. Se puede representar la condición entre corchetes o bien utilizando una expresión del tipo "IF..ELSE". Además la estructura también permitiría condicionales anidados mediante estructuras "ELSE..IF". Uno de los usos más frecuentes de esta estructura es la representación de los posibles problemas dados en el escenario (como en una llamada telefónica, cuando el receptor no descuelga el teléfono)</li>
        <img src="" alt="$$$ Diagrama de secuencia con condicionales $$$">
        <li><b>Iterativas:</b> cuando se necesita realizar una estructura iterativa (de tipo while) se emplea una estructura similar a la figura, indicando la acción a realizar mientras se cumpla la condición. Pueden representarse con un asterisco y entre corchetes los parámetros del bucle (aunque también se pueden indicar las instrucciones de iteración "WHILE" y "END WHILE").</li>
        <img src="" alt="$$$ Diagrama de secuencia con iterativas $$$">
        <li><b>Concurrencia:</b> la concurrencia implica dos o más tareas actuando de forma simultánea. Estos diagramas de secuencia permiten mostrar la concurrencia cuando un objeto envíe más de un mensaje al mismo tiempo. Se representa con un un doble menzaje lanzado en el mismo momento pero a destinos diferentes.</li>
        <img src="" alt="$$$ Diagrama de secuencia con concurrencia $$$">
      </ul>

    <h2>Pasos para la construcción de un diagrama de secuencia</h2>
      <p>
        Los pasos para la construcción de un diagrama de secuencia son:
      </p>
      <ul>
        <li>Indentificar los objetos. Colocarlos de izquierda a derecha y añadir a cada uno su línea de vida.</li>
        <li>Identificar a los actores que operan contra el sistema y colocarles también su línea de vida (recordar que estos actores no portenecen propiamente al sistema)</li>
        <li>A partir de las interacciones expuestas en el caso de uso, identificar los eventos y representarlos mediante líneas que vayan de una línea de vida a otra.</li>
        <li>Identificar, además, el evento inicial.</li>
        <li>De forma opcional, se pueden colocar notas en el diagrama para su mayor comprensión. Las notas son unos elementos aportados por UML que pueden utilizarse en sus diagramas para explicar ciertos aspectos (se representan con un rectángulo con la esquina superior derecha doblada)</li>
      </ul>
      <img src="" alt="$$$ Diagrama de secuencia con notas en la parte inferior $$$">

    <h2>Diagramas de colaboración</h2>
      <p>
        Este tipo de diagrama se centra en los objetos. El <b>diagrama de colaboración</b> muestra los roles de cada uno de los objetos y constituye una de las mejores herramientas para identificarlos.
      </p>
      <p>
        El diagrama representa los objetos, los enlaces existentes y, mediante flechas, los mensaje sque circulan entre ellos. Estos mensajes incorporan el nombre del mensaje y los parámetros en caso de que los hubiese.
      </p>
      <p>
        Aunque no existe una estructura tan cronológicamente ordenada como en los diagramas de secuencia, cada uno de los mensajes lleva un número de secuencia para indicar el orden de cada mensaje y saber, así, cuál se ha ejecutado antes y cuál se ejecutará a posteriori (el primier mensaje no lleva número de secuencia). Los diagramas de colaboración no reflejan temporalidad.
      </p>
      <img src="" alt="$$$ Diagrama de colaboración y su equivalente diagrama de secuencia $$$">

      <p>
        Para los diagramas de colaboración se emplean los siguientes elementos:
      </p>
      <ul>
        <li><b>Enlaces:</b> representa una conexión entre dos objetos e indica que existe interacción entre ambos. Un enlace es una instancia de una asociación. Por un mismo enlace pueden enviarse varios mensajes.</li>
        <li><b>Mensajes:</b> es la información transmitida entre objetos. Se representa con una flecha que indica la dirección del mensaje. A este mensaje se le incorpora un número de secuencia para mostrar el orden (separado del nombre por dos puntos). El mensaje añade al final dos parentesis entre los cuales se indicarán los parámetros (en caso de que los hubiese). En algunos casos los mensajes se derivan de otros mensajes. Para indicarlo se emplea la estrucutra de numeración de los libros que utiliza puntos decimales para señalar los diferentes niveles de anidamiento.</li>
        <img src="" alt="$$$ Diagrama de colaboración $$$">
      </ul>


    <h2>Estructuras de los diagramas de colaboración</h2>
    <p>
      Existen varios tipos de estructura en los diagramas de colaboración:
    </p>
    <ul>
      <li><b>Reflexiva:</b> el objeto se envía el mensaje así mismo. Se representa con un enlace con origen y destino en propio objeto. Además, hay que añadir el sentido de la flecha y el nombre de la acción.</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura reflexiva $$$">
      <li><b>Condicionales:</b> se representan con un número de secuencia y una sentencia condicional encerrada entre corchetes. La única forma de enviar el mensaje es que la cláusula sea verdadera. Al  agregar condiciones se incorpora una bifurcación. Se coloca la condición entre corchetes y estos anteceden el número de orden. En la primera imagen, si pagado es TRUE se envía el mensaje levantar_barrera(). De forma adicional, se puede trabajar el caso en el caso en el cual no se cumpla la condición (en proframación se considera una estructura IF..ELSE). En ese caso se escribe, entre corchetes, la condición negada y, al igual que el caso del IF, se indica a continuación la acción a realizar. En la segunda imagen, se observa que ocurre en caso de que pagado no tenga el valor TRUE, enviando el mensaje pedirTicketValidado(). Para notarlo se incluye una letra después del número de orden (indica exclusividad)</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura condicional IF $$$">
      <img src="" alt="$$$ Diagrama de colaboración con estructura condicional IF..ELSE $$$">
      <li><b>Iterativas:</b> para indicar la iteración, se utiliza un asterisco justo después del número de secuencia y entre corchetes los parámetros del bucle. Esta estrucutra permite también enviar un mensaje a varios objetos de la misma clase (podría asemejarse al concepto de concurrencia).</li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura iterativa $$$">
      <li><b>Cálculo de expresiones:</b> en algunos casos la operación realizada necesita que se desarrolle una determinada operación y devuelva un valor (el concepto clásico de función). Para indicarlo se emplea una expresión cuya parte izquiera sea la variable que recogerá el resultado y cuya parte derecha sea el cálculo realizado. Ambas partes se separan con <code>:=</code></li>
      <img src="" alt="$$$ Diagrama de colaboración con estructura calculo de expresiones $$$">
    </ul>


    <h2>Pasos para la construcción de un diagrama de colaboración</h2>
      <p>
        Los pasos para construir un diagrama de colaboración son:
      </p>
      <ul>
        <li>Para cada una de las operaciones existentes en el sistema, se debe desarrollar un diagrama individual.</li>
        <li>Cada uno de los eventos del sistema se transforma en un diagrama que parte de ese evento como mensaje inicial.</li>
        <li>El sistema de objetos que realizan las tareas parte de la descripción del caso de uso y de las postcondiciones existentes.</li>
        <li>Hay que indicar la secuencialidad de cada mensaje mediante los números de orden.</li>
      </ul>
      <img src="" alt="$$$ Diagrama de colaboración con mensajes y secuencia $$$">


    <h2>Diferencias entre los diagramas de secuencia y colaboración</h2>
      <p>
        Si bien ambos diagrams son semánticamente equivalentes, es decir representan la misma información y pueden convertirse fácilmente entre ellos. Sin embargo existen las siguientes diferencias:
      </p>
      <ul>
        <li>Los diagramas de Colaboración suelen ser más cortos ya que cada mensaje en los Diagramas de Secuencia hay que representarlo en función del tiempo (en vertical).</li>
        <li>Los diagramas de Secuencia apuestan por la cronología. Los diagrams de Colaboración no reflejan temporalidad y es más difícil detectar la secuencialidad.</li>
        <li>La notación de los Diagramas de Secuencia es más fácil.</li>
        <li>Los diagramas de Colaboración muestran mejor el comportamiento concurrente.</li>
      </ul>
      <p>
        En la siguiente figura se puede ver que la activación en el Objeto1 del diagrama de secuencia no figura en el diagrama de colaboración.
      </p>
      <img src="" alt="$$$ Diagrama de colaboración y su equivalente diagrama de secuencia $$$">

    </article>

    <article>
    <h1 id="diagramas_estado_actividades">Diagramas de Estado y Actividades</h1>
    <h2>Concepto de estado</h2> 

      <p>
        Un <b>estado</b> indica un periodo de tiempo en la vida de un objeto. En este lapso de tiempo, el objeto está a la espera de alguna operación, acción, evento, etc. que permita activarlo y así pasar a otro estado.
      </p>

      <p>
        En UML los estados se representan mediante un rectángulo con los bordes redondeados. Esta caja puede tener divisiones dentro (como con las clases):
      </p>
      <ul>
        <li>Nombre del estado (que sea significativo)</li>
        <li>Acciones ejecutadas al realizar una operación relacionada con el estado (acceder, salir o permanecer)</li>
      </ul>
      <img src="" alt="$$$ Imagen clase con dos acciones $$$">

    <h2>Diagramas de estados</h2>

      <p>
        Un <b>diagrama de estados</b> muestra los distintos estados de los que dispone un objeto durante su vida, como se relacionan entre ellos y como responden a determinados eventos. Son los diagramas de transición de estados propuestos en la metodología Booch o los Diagramas de Estados de OMT.
      </p>
      <p>
        El diagrama de estados se representa con un grafo cíclico. Cada uno de los nodos es uno de los estados posibles y los arcos son transiciones dirigidas. Las flechas indican la interacción entre los dos estados.
      </p>

    <h2>Transiciones, acciones y subestados</h2>
    <h2>Subestados y superestados</h2>
    <h2>Diagramas de Actividades</h2>
    <h2>Estructura de los diagramas de actividades</h2>
    <h2>Marcos de responsabilidad ("swim lanes)</h2>
    </article>

    <article>
    <h1 id="modelado_fisico">Modelado físico de un sistema</h1>  
    <h2>Paquetes</h2>
    <h2>Componentes e interfaces</h2>
    <h2>Diagrama de despliegue</h2>
    <h2>De UML a los lenguajes de programación</h2>
    </article>

    <article>
    <h1 id="uml_2">UML 2.0</h1> 
    <h2>Las versiones de UML</h2> 
    <h2>Objetivos de UML 2.0</h2>
    <h2>Reestructuración de UML 2.0</h2>
    <h2>En su sitio</h2>
    <h2>Diagramas Estructurales</h2>
    <h2>Diagramas de Comportamiento</h2>
    <h2>Diagramas de Interacción</h2>
    </article>

  </div>
</section>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h2>Reference List</h2>
    <ol>
      <!--li><cite id="refGoFBook"> E. Gamma, et al., Design Patterns: Elements of Reusable Object-Oriented Software. Boston, MA: Addison-Wesley Longman Publishing Co., Inc., 2000.</cite></li-->
    </ol>
  </div>
</section>

<footer id="footerSocialMedia">
  <div class="container">
    <div class="row center-block">
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://www.linkedin.com/in/domingoesteban"><img class="footericon" src="../../images/icons/linkedin2-circle-logo-128.png" alt="Linkedin"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://github.com/domingoesteban"><img class="footericon" src="../../images/icons/github2-circle-logo-128.png" alt="Github"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://twitter.com/domingoesteban"><img class="footericon" src="../../images/icons/twitter2-circle-logo-128.png" alt="Twitter"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://google.com/+DomingoEsteban"><img class="footericon" src="../../images/icons/googleplus2-circle-logo-128.png" alt="Google Plus"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.youtube.com/user/domingoestebanc"><img class="footericon" src="../../images/icons/youtube2-circle-logo-128.png" alt="Youtube"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.facebook.com/domingoesteban"><img class="footericon" src="../../images/icons/facebook2-circle-logo-128.png" alt="Facebook"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://instagram.com/domingoesteban"><img class="footericon" src="../../images/icons/instagram2-circle-logo-128.png" alt="Instagram"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vine.co/domingoesteban"><img class="footericon" src="../../images/icons/vine-circle-logo-128.png" alt="Vine"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vimeo.com/domingoesteban"><img class="footericon" src="../../images/icons/vimeo-circle-logo-128.png" alt="Vimeo"/></a>
      </div>
    </div>
  </div>

  <div class="col-xs-12" id="footerCopyright">
    <h6 class="text-center">Copyright © 2014 Domingo Esteban</h6>
    <!-- <p class="text-center"><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> </p> -->
  </div>

</footer>

<!-- JAVASCRIPT (At the bottom for faster page loading)-->

<!-- jQuery -->
<script src="https://code.jquery.com/jquery.js"></script> <!-- Online version 1 -->
<!--script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script--> <!-- Online version 2 -->

<!-- ARREGLAR!!!! -->
<!--script>window.jQuery || document.write('<script src="includes/js/jquery.js"></script>')</script--> <!-- If no online access 1 -->
<!--script src="includes/js/jquery.js"> </script--> <!-- If no online access 2 -->

<!-- Bootstrap JS -->
<script src="../framework/js/bootstrap.js"> </script>

<!-- Custom JS -->
<script src="../includes/js/scripts.js"></script>

</body>

<!-- PAGINA PARA FORMATO DE REFERENCIAS: http://www.york.ac.uk/integrity/ieee.html -->

</html> 