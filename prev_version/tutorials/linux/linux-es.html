<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Tutorial de Linux - Domingo Esteban</title>
  <meta name="keywords" content="Domingo, Esteban, Cabala, Robotics, Peru, España, Madrid, Arequipa, Linux, Networks, TCP-IP, Apache">
  <meta name="description" content="Tutorial de Linux - Domingo Esteban">
  <meta name="author" content="Domingo Esteban">

  <!-- Mobile viewport optimized -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <!--meta name="viewport" content="width=device-width, initial-scale=1"-->

  <!-- Bootstrap CSS -->
  <!-- <link rel="stylesheet" href="../framework/css/bootstrap.css"> -->
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet'/>
<link href='http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css' rel='stylesheet'/>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../includes/css/styles.css"/>
  <link rel="stylesheet" href="../../includes/css/tutorials-styles.css"/>

  <!-- Including Modernizr (Before any other Javascript) -->

  <!-- Favicon -->
  <link href="../../images/icons/robot-favicon.ico" rel="icon" type="image/x-icon" />

</head>

<body>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h1 align="center">Linux</h1>

    <article>

      <h1>Introducción</h1>
        <p>
          <b>Linux</b>, hace referencia a un sistema operativo propiamente dicho y al nombre de un núcleo de una gran cantidad de colección de sistemas.
        </p>

        <p>
          <b>GNU/Linux:</b> Colecciones de software que suelen contener grandes cantidades de paquetes de software y herramientas además del núcleo.
        </p>

        <h2>Distribuciones de Linux </h2>
          <p>
            Las distribuciones son desarrollos completos con un núcleo en común.
          </p>

        <h2>Kernel de Linux</h2>
          <p>
            El kernel o núcleo de Linux es el encargado de que el software y el hardware puedan trabajar juntos. Las funciones más importantes del kernel son:
            <ul>
              <li>Administración de la memoria para todos los programas y procesos en ejecución.</li>
              <li>Administración del tiempo de procesado que los programas y acciones en ejecución utilizan.</li>
              <li>Permitir el acceso a los periféricos y elementos del ordenador.</li>
            </ul>
          </p>
          <p>
            Hay dos tipos de versiones del núcleo:
            <ul>
              <li><b>Versión de producción:</b> Es la versión estable y resultado final de las versiones de desarrollo o experimentales.</li>
              <li><b>Versión de desarrollo:</b> (o versión experimental). Utilizado para programar, comprobar y verificar nuevas características, correcciones, etc. Estos núcleos suelen presentar alguna inestabilidad.</li>
            </ul>
          </p>

        <h2>Fedora Core</h2>
          <p>
            El proyecto Fedora, que produce y mantiene Fedora Core, es una colaboración entre Red Hat Inc. y la comunidad software libre y codigo abierto (FOSS).
          </p>

          <p>
            Su principal objetivo es conseguir un sistema operativo de propósito general, basado exclusivamente en software libre con el apoyo de la comunidad Linux.  
          </p>
          <p>
            Se llama Core, porque incluye sólo el núcleo, las partes más básicas del sistema operativo. Para incluir nuevo software, hay que incluir los repositorios.
          </p>
          <p>
            Los <b>repositorios</b> son los lugares de los cuales se puede descargar los paquetes de software para su posterior instalación. Con el fin de descargar, descomprimir e instalar los paquetes se utiliza <b>apt-get</b>, <b>yum</b>, <b>aptitude</b>, entre otros.
          </p>
        
        <h2>Proceso de instalación</h2>
          <p>
            Cuando se formatea el disco duro y se reparticiona para ubicar el sistema operativo, lo hace con una partición especial: <b>swap</b>, que opera fundamentalmente sobre la carga del sistema.
          </p>
          <p>
            Para poder realizar la partición, se suele utilizar programas especiales, como Partition Magic.
          </p>
          <p>
            El proceso de instalación de fedora se compone de dos partes: arranque desde el CD-ROM y arranque de Fedora.
          </p>

        <h2>El proceso de arranque</h2>
          <p>
            Cuando la BIOS termina sus chequeos y comprobaciones, empieza a buscar dónde hay software para ser ejecutado. Para este fin primero analiza la unidad de arranque por defecto (CD-ROM o disco duro), y si no se encuentra la unidad o su contenido no tiene software de arranque, pasa a la siguiente unidad.
          </p>

          <p>
            El <b>registro de arranque principal o maestro</b> (Master Boot Record - MBR), es el primer sector ("sector cero") de un disco duro. Es aquí donde, usualmente, se encuentra el <b>gestor de arranque</b> (bootloader). La principal función del este programa es posibilitar la elección del sistema operativo que continuará con el arranque del sistema. Los gestores de arranque más habituales en las distribuciones Linux son: LILO y GRUB.
          </p>

          <p>
            Con estos gestores de arranque se puede utilizar más de un sistema operativo. Para la distribución Fedora, el gestor de arranque que se utiliza es GRUB.
          </p>

          <p>
            Cuando el kernel ya ha montado el sistema de archivos, comenzarán a iniciarse algunos procesos. La mayoría de estos corresponden a los <b>demonios</b>, que van a realizar y controlar determinadas tareas durante la sesión. Estos demonios pueden configurarse, deternerse, pausarse, reiniciarse, por el usuario.
          </p>

        <h2>Software adicional para GNU/Linux</h2>
          <p>
            Conviertiendo una aplicación en un paquete que además de todos sus archivos comprimidos contiene metainformación acerca de la propia aplicación. Con esto se consigue que un programa interno pueda ofrecer una interfaz de administración sencilla apra agregar nuevos programas y quitar otros ya instalados. El propio sistema Linux opera en forma de paquetes, consiguiendo una actualización y mantenimiento más sencillo.
          </p>

          <p>
            El software para Linux se puede encontrar en dos maneras: en un paquete binario o en un paquete con su código fuente.
          </p>
          <p>
            Al haber distintas distribuciones, que a su vez, están preparadas para distintas versiones de procesadores, existen varios tipos de paquetes binarios. Varias de las distribuciones comparten el sistema de paquetes que utilizan, los más comunes son: 
            <ul>
              <li><b>Paquetes RPM:</b> Usados por las distribuciones Redhat, Caldera, Mandrake/Mandriva, Suse, Turbolinux y Fedora. Su instalación se realiza a través de RPM o Yum.</li>
            </ul>
          </p>

          <p>
            Los paquetes en código fuente se instalan a través del proceso de:
              <ol>
                <li>Descompresión</li>
                <li>Configuración. Proceso para adaptarlo a la distribución o versión de Linux.</li>
                <li>Pre-compilación. Proceso para adaptar el paquete a las necesidades del sistema, a través del comando <b><code>make</code></b></li>
                <li>Instalación. Proceso para compilar todo y proceder a la instalación definitiva. Usualmente se realiza a través del comando <b><code>make install</code></b></li>
              </ol>
          </p>
          <p>
            El principal problema de instalar un programa con código fuente reside en su desinstalación, debido a que suele compartir librerías con otros programas.
          </p>

        <h2>Yum</h2>
          <p>
            Yum es un programa que automatiza la instalación y desinstalación de los paquetes RPM del sistema. Así mismo, obtiene automáticamente las dependencias de software y previene al sistema sobre lo que será encesario disponer para instalar correctamente los paquetes.
          </p>

          <p>
            Antes de utilizar yum por primera vez, hay que actualizar las fuentes con <b><code>yum check-update</code></b>
          </p>

          <p>
            Para instalar un paquete nuevo, se utiliza el argumento install, <b><code>yum install</code></b>
          </p>

        <h2>Estructura del sistema de archivos de Linux</h2>

          <p>
            Las particiones FAT32 o NTFS, son subestructuras asociadas a las particiones del disco del disco duro, que configura la forma y lugar con las que el sistema operativo ubica los registros. Para este fin, se utiliza todo tipo de apuntadores, tablas de asignación, índices, etc., a modo de base de datos.
          </p>

          <p>
            El símbolo de la base del sistema de archivos de Linux, es la barra inclinada (/) y, partiendo de ella, se montan el resto de los directorios.
          </p>

          <p>
            El directorio home es un directorio creado especialmente para los usuarios distintos del superusuario o root. El superusuario puede "ver" al resto de usuarios, controlarlos, auditarlos o autorizarlos, y al que sólo tiene acceso él mismo.
          </p>
          <p>
            Todos los archivos de Linux tienen un nombre que debe cumplir unas ciertas reglas:
            <ul>
              <li>El nombre debe tener entre 1 y 255 caracteres</li>
              <li>Se puede utilizar cualquier carácter excepto la barra inclinada /, sin embargo, se recomienda no emplear los caracteres con significado especial para Linux: = ^ ~ ' " ` * ; - ? [ ] ( ) ! &amp; &lt; &gt; </li>
              <li>Para emplear ficheros con estos caracteres o espacios hay que introducir el nombre del fichero entre comillas</li>
              <li>Las letas mayúsculas y minúsculas se consideran diferentes caracteres (case-sensitivity).</li>
            </ul>
          </p>
          <p>
            Linux sólo distingue tres tipos de archivos:
            <ul>
              <li>Archivos o ficheros ordinarios</li>
              <li>Directorios o carpetas</li>
              <li>Archivos especiales</li>
            </ul>
          </p>

        <h2>Árbol de directorios típicos de Linux</h2>
          <p>
            La barra indica el punto de montaje que, como en todos los sistemas de archivos de UNIX, representa un orígen único raíz. El resto de los directorios se organizan de la siguiente manera:
            <ul>
              <li><b>bin</b> - Almacena programas esenciales del sistema, como las órdenes y comandos, así como todos los archivos ejecutables.</li>
              <li><b>boot</b></li>
              <li><b>dev</b> - contiene los diferentes controladores de los dispositivos.</li>
              <li><b>etc</b> - Agrupa los archivos que hacen referencia a la configuración del sistema.</li>
              <li><b>home</b></li>
              <li><b>lib</b> - Guarda imágenes de las librerías compartidas, es decir, archivos con códigos que comparten varios programas.</li>
              <li><b>proc</b> - Se trata de un sistema de archivos virtual. Los archivos que contiene residen en la memoria, no en un disco, y generalmente. sólo se puede obtener información sobre ellos.</li>
              <li><b>root</b></li>
              <li><b>sbin</b> - Contiene programas que son únicamente accesibles por el superusuario.</li>
              <li><b>tmp</b> - Almacena archivos con información temporal necesaria para la ejecución de algunos programas.</li>
              <li><b>usr</b> - Agrupa un conjunto de subdirectorios donde se agrupan programas y archivos de configuración de los usuarios.</li>
              <li><b>var</b></li>
            </ul>
          </p>

          <p>
            El comando <b><code>cd</code></b> permite cambiar el directorio de trabajo o directorio actual. Es la abreviatura de <i>change directory</i>. Por ejemplo para cambiarse al directorio home, se utilizaría el comando <code>cd /home</code>
          </p>

          <p>
            Para cambiar a un directorio o subdirectorio que está ubicado de forma paralela al punto donde se está actualmente, basta con hacer referencia a la nueva ubicación desde su punto inicial de montaje.  
          </p>

        <h2>Usuarios de Linux</h2>

          <p>
            En Linux, el acceso al sistema se realiza imponiendo un registro que identifica al usuario que está actuando sobre la máquina. Existen dos grupos de usuarios bien diferenciados: los usuarios normales y el super usuario root.
          </p>

          <p>
            El comando <b><code>su</code></b> hace referencia al <b>login</b> del sistema y a los permisos, es decir, al modo de acceso al sistema por parte de los usuarios. La principal utilidad de este comando es el cambio de usuario dentro del sistema mediante su login, o nombre de usuario, y una contraseña. Esto incluye el cambio de sesión a root.
          </p>

          <p>
            El acceso al sistema como root habilita una serie de permisos y privilegios que posibilita cambiar la totalidad de configuraciones del sistema, con el el riesgo que supone. Por lo que lo más recomendable es trabajar como usuario normal y actuar como super usuario sólo en los casos en que sea necesario.
          </p>

          <p> 
            Para cambiar de usuario se realiza el comando:
          </p>  
            <pre>
              <code>$ su nombreusuario</code>
            </pre>
          

          <p>
            La invocación del comando su, sin indicar el login, se utiliza para acceder directamente al super usuario.
          </p>

          <p>
            Para salir del usuario al que se ha cambiado, y regresar al usuario normal se introduce el comando <b><code>exit</code></b>
          </p>

          <p>
            Para determinar la identidad del usuario con el que se está trabajando, se utiliza el comando <b><code>whoami</code></b>. Así mismo, para saber si el usuario actual es normal o es root, se debe de mirar el símbolo que aparece en el raíz del terminal: será un <b>$</b> para uno normal y <b>#</b> para el super usuario.
          </p>

        <h2>Acceso a Linux</h2>
          <p>
            Existen 3 formas de acceder a un sistema Linux:
          </p>  
            <ul>
              <li>Desde una <b>consola de texto:</b> El usuario se conecta directamente al ordenador que tiene instalado Linux y accede mediante un sistema no gráfico que suele llamarse terminal virtual o ventana de comandos.</li>
              <li>Desde un <b>gestor de sesiones gráfico X window:</b> El usuario accede mediante un entorno gráfico</li>
              <li>Desde una <b>computadora remota:</b> El acceso se realiza através de telnet o secure shell (ssh)</li>
            </ul>
          
          <p>
            El cambio de modo gráfico a texto se realiza a través de las teclas <b><i>Ctrl + Alt + F1-F6</i></b> para cambiar a cada uno de los 6 terminales virtuales que pueden trabajar simultáneamente. Para pasar de un terminal virtual al modo gráfico se utiliza <b><i>Ctrl + Alt + F7</i></b>
          </p>

          <p>
            El modo texto se basa en la ejecución de una serie de comandos que son interpretados por un programa o shell. Linux dispone de varios de estos programas, pero el más habitual es <b>bash</b>.
          </p>

        <h2>Scripts de inicio del sistema. Runlevels</h2>
          <p>
            La mayoría de las distribuciones de Linux se rigen por el <b>System V init</b> para gestionar los scripts de arranque. Aunque hay pequeñas diferencias entre distribuciones, principalemente hacen referencia a en qué directorio están ubicados determinados ficheros.
          </p>

          <p>
            Otras distribuciones, como Gentoo o Slackware, tienen un método distinto (Gentoo usa un System V modificado y Slackware usa el sistema BSD init)
          </p>

          <p>
            Los runlevels o niveles de ejecución son un concepto importante en los sistemas UNIX y Linux. Habitualmente se dispone de 7 niveles, del 0 al 6, aunque pueden existir más en algunas distribuciones.
          </p>

          <p>
            Si la máquina sólo va a funcionar como servidor, se configura para usar el runlevel correspondiente, que sólo carga al inicio los demonios y herramientas necesarias para los servidores y no cargaría, por ejemplo, el servidor gráfico de ventas X-window. Por el contrario, si va a funcionar como una PC de escritorio, se configura para usar otro runlevel y así se evita detener los demonios que no se necesita.
          </p>

          <p>
            El runlevel 0 es para apagar la máquina, y el runlevel 6 para reiniciarla. Es obvio, que no se debe de poner estos runlevel por defecto a ninguno de estos dos; de hacerlo, el sistema no llegaría a arrancar.
          </p>

          <p>
            El runlevel 1 queda reservado para el modo monousuario que servirá para administrar la máquina. Normalmente este modo no dispone de red y solicita el password de root antes de permitir ejecutar algún comando.
          </p>

          <p>
            En la ruta <i>/etc/init.d</i> residen unos scripts, uno por cada servicio, que aceptan siempre un primer argumento, start o stop, para arrancar o detener el servicio. En cada runlevel se puede decidir cuáles de estos scripts se ejecutarán y cuáles no. Para hacer esto, cada runlevel tiene un directorio asociado, <b><code>/etc/rcN.d</code></b> o bien <b><code>/etc/rc.d/rcN.d</code></b>, dependiendo de la distribución de Linux, donde <i>N</i> indica el número de runlevel correspondiente.
          </p>

          <p>
            Dentro de cada uno de estos directorios, hay una serie de enlaces simbólicos que apuntan hacia los scripts de los servicios en <b><code>/etc/init.d</code></b>. Para un runlevel determinado, sólo habrá enlaces para los servicios que se queiran ejecutar en ese runlevel.
          </p>

          <p>
            El nombre genérico de estos enlaces son <i>ANNservicio</i>, donde <i>A</i> es una letra, y <i>NN</i> es un número. El objectivo de esta forma de nombrarlos es que en cada runlevel, los scripts se ejecuten en orden alfabético. Así, para la misma letra, un número bajo indica que será ejecutado antes que uno alto.
          </p>

          <p>
            Inmediatamente después que el kernel se cargue en memoria, inicialice el hardware adecuadamente, y monte el sistema de ficheros, el comando <b><code>/sbin/init</code></b> da lugar al primer proceso del sistema, <b>init</b>, qe es el padre de todos los procesos y el encargado de gestionar la configuración de los runlevels para iniciar los servicios adecuados. init lee el fichero <b><code>/etc/inittab</code></b> para determinar cuál es el runlevel por defecto, y algunas opciones de configuración.
          </p>

          <p>
            Antes de iniciar el runlevel correspondiente, lo más común es que se ejecute un script (independientemente de número de runlevel). El nombre y la ubicación de este script se especifican también en <i>/etc/inittab</i>. Su misión es realizar tareas imprescindibles como inicializar el teclado, los puertos serie, resolver dependencias de los módulos, sincronizar el reloj del sistema con el reloj del hardware, definir el nombre del host, etc.
          </p>

          <p>
            A continuación, <i>init</i> recurre a los enlaces simbólicos de <i>/etc/rcN.d</i> (o equivalente) para ejecutar cada unod e ellos con su primer argumento, en este caso, start. Esto arranca los servicios correspondientes del runlevel creando los nuevos procesos correspondientes. Seguidamente, ejecutará los terminales que se mantendrán a la espera del login de los usuarios. A partir de este momento, el sistema ya ha arrancado completamente y es utilizable.
          </p>

        <h2>Arrancar y parar servicios por separado</h2>
          <p>
            Con el sistema iniciado en un runlevel determinado, puede surgir la necesidad de activar o desactivar un sólo servicio. Se puede cambiar el runlevel, pero no es aconsejable si se quiere detener la totalidad de servicios del mismo.
          </p>
          <p>
            Desde la consola, con una sesión de administrador, se puede ejecutar el comando <b><code>kill</code></b> para terminar un servicio refiriendose a su proceso. También se puede situar el demonio que se quiera iniciar y hacer que se ejecute en segundo plano.
          </p>

          <p>
            Para iniciar la ejecución del servicio Apache 2 (servidor web):
          </p>
            <pre>
              <code><br/>$ su <br/># /etc/init.d/apache2 start</code>
            </pre>

          <p>
            Para recargar la configuración del servicio Apache2
          </p>
            <pre>
              <code><br/>$ su <br/># /etc/init.d/apache2 reload</code>
            </pre>

          <p>
            Para detener la ejecución del servicio Apache2
          </p>
            <pre>
              <code><br/>$ su <br/># /etc/init.d/apache2 stop</code>
            </pre>


      <h1>Redes en Linux</h1>

        <h2>TCP/IP en Linux </h2>

        <h2>Configuración HW de red</h2>

        <h2>Servicios y control de acceso</h2>
          <h3>Niveles de ejecución</h3>
          <p>
            Un <b>nivel de ejecución</b> o runlevel, es cada uno de los estados de ejecución (modos de operación) en que se puede encontrar el sistema operativo Linux. Según la base estándard para Linux (LSB), debe haber, en general, 7 niveles niveles de ejecución:
            <ul style="list-style-type: none;">
              <li>(0) <b>Halt:</b> (Parada) Apaga el sistema.</li>
              <li>(1) <b>Single-user mode:</b> (Monousuario) Modo texto usuario único root para tareas administrativas.</li>
              <li>(2) <b>Multi-user mode:</b> Multiusuario sin soporte de red, usuario-definible. No configura las interfaces de red y no exporta los servicios de red.</li>
              <li>(3) <b>Multi-user mode with networking:</b> Multiusuario con soporte de red, modo texto multiusuario. Comienza el sistema de forma normal.</li>
              <li>(4) <b>Not used / User-definable:</b> Sin usar (usuario-definible). Para propósitos especiales.</li>
              <li>(5) <b>Multi-user with display manager:</b> Multiusuario en modo gráfico (con pantalla de inicio de sesión basada en X). Al igual que el nivel de ejecución 3, pero con gestor de pantalla.</li>
              <li>(6) <b>Reboot:</b> Reinicia el sistema</li>
            </ul>
          </p>
          <p>
            El nivel de ejecución por defecto para el sistema está listado en el fichero <b><code>/etc/inittab</code></b>
          </p>

          <h3>Configuración de Servicios</h3>
          <p>
            En Linux existen diferentes servicios de arranque. Estos servicios tienen procedimientos de inicio y parada que permiten su trabajo sin necesidad de supervisión, y se ejecutan a través de <b>scripts</b> que se encuentran generalmente en el directorio <b><code>/etc/init.d</code></b>
          </p>
          <p>
            En el caso de Fedora, se puede utizar la herramienta <b>redhat-config-services</b> que permite activar o desactivar estos servicios.
          </p>
          <p>
            Para poder activar y desactivar estos servicios, se puede utilizar el comando <b><code>chkconfig</code></b>. Utilizando el argumento -list, es decir <b><code>chklist -list</code></b>, se obtiene una lista de los servicios y si están iniciados o detenidos para cada nivel de ejecución. Al final de la lista, se enumeran los servicios manejados por xinetd.
          </p>


        <h2>Redes y servidores</h2>
          <p> 
            Internet está compuesto por varios equipos heterogéneos interconectados, cada uno de estos equipos se denomina host.
          </p>
          <p>
            El protocolo HTTP funciona siguiendo el modelo cliente-servidor. El cliente es una aplicación que ejecuta peticiones en el protocolo de aplicación y las envía a través de la red. El servidor permanece "escuchando" a través de un puerto, por el que se reciben las peticiones del cliente, y posteriormente ejecuta el código correspondiente para servirlas. Se responde al cliente con los resultados.
          </p>
          <p>
            En Internet se distinguen tres tipos de host:
          </p>
            <ul>
              <li>Máquinas de usuarios que actúan como clientes y se conectan a proveedores secundarios.</li>
              <li>Máquinas de proveedores de servicios de Internet que se conectan a proveedores primarios.</li>
              <li>Máquinas de proveedores primarios de Internet, que se conectan a backbones.</li>
            </ul>

          <h3>Modelo cliente-servidor</h3>
            <p>
              Arquitectura de software que describe el procesamiento entre dos o más programas: una aplicación y un servicio soporte. El modelo soporta un medio ambiente distribuido, en el cual los requerimientos de servicio hechos por estaciones de trabajo inteligentes o clientes, resultan en un trabajo realizado por otras computadores llamados servidores.
            </p>
            <p>
              Los elementos de la arquitectura Cliente-servidor son:
            </p>
              <ul>
                <li>El <b>puesto de trabajo</b> o <b>Cliente</b>: Es el PC del usuario, que le permite acceder y gestionar una serie de recursos, el cual se perfila como un puesto de trabajo universal.</li>
                <li>Los <b>Servidores</b> o <b>Back-end</b>: Son las máquinas que suministran una serie de servicios como bases de datos, archivos, comunicaciones, etc.</li>
              </ul>
            <p>
              Los servidores, según la especialización y los requimientos de los servicios que deben suministrar, pueden ser: mainframes, minicomputadoras especializadas o dedicadas, etc.
            </p>

          <h3>HTTP</h3>
            <p>
              La Web utiliza direcciones de recursos (documentos) que se denominan <b>URL</b> (Uniform Resource Locator). Estos URL permiten especificar: el protocolo que se utiliza para obtener el documento, el nombre del host que lo contiene, el puerto TCP/IP en el qu está escuchando el servidor que contiene el documento y el documento en sí. Sin embargo, en la mayoría de URL no se especifica el puerto del servidor al que se debe conectar porque para cada servidor   existe un puerto predefinido que es el que se tiende a utilizar.
            </p>
            
            <p>
              El protocolo <b>HTTP</b> (Hypertext Transfer Protocol) es un protocolo que funciona sobre los servicios del TCP/IP y se usa para el intercambio de información entre los clientes (navegadores) y los servidores HTTP (Apache, Internet Information Server, etc.)
            </p>

            <p>
              El hipertexto es el contenido de las páginas Web, y el protocolo de transferencia es el sistema mediante el cual se envían las peticiones de acceso a una página Web, la respuesta del servidor para remitirla y envíar información adicional en ambos sentidos de la comunicación.
            </p>

            <p>
              HTTP es un protocolo sin estado, por lo que no se almacena ningún tipo de información sobre conexiones anteriores. Al finalizar la transacción todo se pierde. Por este motivo se usan pequeños archivos que se guardan en los equipos para proporcionar la información necesaria al sitio Web y establecer la conexión, como es el caso de los login de una cuenta de correo.
            </p>

            <p>
              En el protocolo HTTP, los clientes envían sus peticiones y mensajes a su puerto 80 usando TCP/IP. Tras procesar la operación, el servidor responde con otro mensaje que puede incluir estados, datos o código de error, según el resultado de la operación solicitada.
            </p>

            <p>
              Todas las operaciones pueden ejecutar un objeto o recurso sobre el que actúan: cada objeto Web se identifica por su URL. El servidor y los clientes saben que hacer porque usan descripciones <b>MIME</b> (Multipurpose Internet Mail Extensions), que describen el tipo de documento que se ha transferido, con el fin de intercambiar a través de internet todo tipo de archivos de forma transparente para el usuario.
            </p>

            <p>
              MIME adjunta un archivo de cabecera a cada archivo, especificando el tipo y el subtipo del contenido del archivo principal. Con esta inforación tanto el navegador como el servidor, pueden manejar y presentar correctamente los datos.
            </p>

            <p>
              Los mandatos básicos del protocolo HTTP (páginas web u otro tipo de archivos), son los siguientes:
            </p>
              <ul>
                <li><b>GET</b>: Solicita leer una página web u otro objeto.</li>
                <li><b>HEAD</b>: Solicita leer la cabecera de una página web.</li>
                <li><b>PUT</b>: Solicita almacenar una página web u otro objeto.</li>
                <li><b>POST</b>: Envía datos a una aplicación web.</li>
                <li><b>DELETE</b>: Borra una página web u otro objeto.</li>
                <li><b>LINK</b>: Conecta a dos recursos existentes.</li>
                <li><b>UNLINK</b>: Rompe una conexión existente entre dos recursos.</li>
              </ul>


          <h3>Etapas de una Transacción HTTP</h3>

            <p>
              Cada vez que un cliente realiza una petición a un servidor, se ejecutan los siguientes pasos:
            </p>

              <ul>
                <li>El usuario accede a una URL, seleccionando un enlace de un documento HTML o introduciéndola directamente en la barra de dirección del cliente web.</li>
                <li>El cliente decodifica la URL, separando sus diferentes partes: protocolo de acceso, la dirección DNS o IP del servidor, el posible puerto opcional (el valor por defecto es 80) y el objeto que se está solicitando al servidor.</li>
                <li>Se abre una conexión TCP-IP con el servidor, llamando al puerto TCP correspondiente.</li>
                <li>Se realiza la petición enviando el comando necesario (GET, POST, HEAD, etc.), la dirección del objeto requerido (el contenido de la URL que sigue a la dirección del servidor), la versión del protocolo HTTP empleada (usualmente HTTP/1.0) y un conjunto variable de información que incluye datos sobre las capacidades del explorador y datos opcionales para el servidor.</li>
                <li>El servidor devuelve la respuesta al cliente, que contiene un código de estado y el tipo de dato MIME de la información de retorno, seguido de la propia información.</li>
                <li>Finalmente, se cierra la conexión TCP.</li>
              </ul>

          <h3>Servidores Web</h3>
            <p>
              El protocolo HTTP no se ejecuta por sí mismo, sino que se implementa mediante los servidores Web, que son los responsables de establecer las distintas negociaciones.
            </p>

            <p>
              Es importante diferenciar HTTP de HTML. HTML es un formato de archivos no ejecutable generado mediante código de marcación o etiquetas, mientras que HTTP es un protocolo de comunicación.
            </p>

            <p>
              Un <b>servidor Web</b> se encarga de mantenerse a la espera de peticiones HTTP llevadas a cabo por un cliente (navegador). El navegador realiza la petición al servidor y éste le responde con el contenido que el cliente solicita.
            </p>

            <p>
              Cuando un usuario teclea el nombre de una página web en el navegador, éste realiza una petición HTTP al servidor de dicha dirección. El servidor responde al cliente enviando el código HTML de la página; al recibir el código, el cliente lo interpreta y lo muestra en pantalla.
            </p>

            <p>
              Por lo tanto, el cliente se encarga de solicitar e interpretar el código HTML, mientras que el servidor se limita a transferir el código de la página sin llevar a cabo ninguna interpretación del mismo.
            </p>

            <p>
              Las <b>aplicaciones Web</b> son fragmentos de código que se ejecutan cuando se realizan ciertas peticiones o respuestas HTTP. Existen 2 tipos:
            </p>
              <ul>
                <li><b>Aplicaciones en el lado del cliente:</b> El cliente Web es el encargado de ejecutar la aplicación en el equipo del usuario. El servidor proporciona el código de las aplicaciones o <b>scripts</b>, y es el cliente, mediante el navegador, que las ejecuta. Los navegadores permiten ejecutar aplicaciones escritas en lenguajes Javascript y Java, aunque pueden añadirse más lenguajes mediante el uso de "plugins".</li>

                <li><b>Aplicaciones en el lado del servidor:</b> El servidor Web es quien ejecuta la aplicación. Una vez ejecutada, genera cierto código HTML que envía al cliente por medio del protocolo http.</li>
              </ul>

          <h3>Domain Name Service (DNS)</h3>
            <p>
              El <b>DNS</b> es una base de datos distribuida y jerárquica que almacena información asociada con los nombres de los dominios en redes como Internet.
            </p>

            <p>
              Aunque el DNS puede asociar distintos tipos de información a cada nombre, los usos más comunes son: la asignación de nombres de dominio a direcciones IP y la localización de los servidores de correo electrónico de cada uno de ellos.
            </p>

            <p>
              El sistema de nombres de dominios en Internet es un sistema distribuido, jerárquico, replicado y tolerante a fallos. El sistema se basa en una estructura de árbol que define una jerarquía entre los dominios y los subdominios.
            </p>

            <p>
              En un nombre de dominio, la jerarquía se lee de derecha a izquierda. Por ejemplo, www.domain.com, el dominio más alto es com. Por otra parte, la raíz del árbol está representada por un "punto" al final del nombre (aunque no se escribe), todos los dominios están bajo ésta raíz.
            </p>

            <p>
              Cada componente del dominio (y también la raíz) tiene un servidor primario y varios servidores secundarios. Todos estos servidores tienen la misma autoridad para responder por el dominio, pero el primario es el único con derecho para hacer modificaciones en él. Por este motivo, el servidor primario tiene la copia maestra y los secundarios copian la información desde él.
            </p>

            <p>
              El <b>servidor de nombres</b> es un programa que suele ser una versión de BIND (Berkeley Internet Name Daemon). Es recomendable siempre utilizar la última versión desde Internet (<a href="http://www.isc.org">www.isc.org</a>)
            </p>

            <p>
              La raíz del sistema de dominios es proporcionada por algunos servidores "bien conocidos". Todo servidor de nombres debe ser configurado con la lista de los servidores raíz "bien conocidos" (que usualmente vienen de fábrica). Estos servidores indican que dominios de primer nivel existen y cuáles son sus servidores de nombres. Estos servidores de dominio, a su vez, indican que subdominios existen y cuáles son sus servidores.
            </p>


          <h3>Consideraciones sobre los servidores Web</h3>
            <p>
              Una configuración adecuada de un servidor Web, debe asegurar: seguridad, servicios, rápidez, compatibilidad, escalabilidad, rendimiento y eficacia.
            </p>

          <h3>Instalación de Apache 2</h3>
            <p>
              El servidor <b>Apache HTTP</b> es un servidor Web de tecnología Open Source sólido, de uso comercial y que está desarrollado por la Apache Software Foundation Red Hat Linux. Incluye el servidor Apache HTTP versión 2.0 así como también una serie de módulos de servidor diseñados para mejorar la funcionalidad.
            </p>

            <p>
              Apache se ejecuta en entornos multitarea, se instala en un directorio del sistema operativo, típicamente en <code>/usr/local/httpd</code>, entre otros. Este directorio se denomina <b>directorio base</b> y contiene tres subdirectorios:
            </p>
              <ul>
                <li><b>Conf</b>: contiene los archivos de configuración de Apache.</li>
                <li><b>Htdocs</b>: contiene las páginas HTML que componen el sitio Web.</li>
                <li><b>Logs</b>: contiene los archivos de log, tanto de los accesos correctos como los errores.</li>
              </ul>

            <p>
              El archivo ejecutable que contiene el servidor se llama <code>httpd</code>, a este ejecutable se le pueden proporcionar varios parámetros:
            </p>
              <ul style="list-style: none;">
                <li><b>-v</b>, muestra la versión del programa.</li>
                <li><b>-h</b>, muestra las diferentes directivas de la configuración disponibles.</li>
                <li><b>-d</b>, define el directorio base del servidor apache.</li>
              </ul>

            <p>
              Una vez instalado Apache 2.0, para verificar el buen funcionamiento del servidor, se puede utilizar el siguiente comando:
            </p>
            <pre><br><code># cd /etc/httpd</code><br><code># /bin/apachectl start</code>
            </pre>
            <p>
              Para arrancar el servidor también se puede utilizar:
            </p>
            <pre><br><code># httpd -k start</code>
            </pre>

            <p>
              Posteriormente, se abre un navegador de archivos y se coloca la dirección: <i>http://localhost</i>. Se debe de ver en el navegador una página de testeo de la aplicación.
            </p>

            <p>
              Para detener Apache, se utilizan los siguientes comandos:
            </p>
            <pre><br><code># cd /etc/httpd</code><br><code># /bin/apachectl stop</code>
            </pre>
            <p>
              Adicionalmente, para detener el servidor se puede utilizar:
            </p>
            <pre><br><code># httpd -k stop</code>
            </pre>

          <h3>Arquitectura en Módulo de Apache</h3>
            <p>
              Apache está estructurado en módulos. La configuración de cada módulo se hace mediante la configuración de las directivas que están contenidas dentro del módulo. Los módulos pueden clasificarse en 3 categorías:
            </p>
              <ul>
                <li><b>Módulos base</b>: Contiene las funciones básicas de Apache.</li>
                <li><b>Módulos Multiproceso</b>: Responsables de la unión con los puertos de la máquina, lo que permite aceptar las peticiones.</li>
                <li><p>Módulos Adicionales</p>: Cualquier otro módulo que añada alguna funcionalidad extra al servidor.</li>
              </ul>
            <p>
              Para añadir un conjunto de utilidades al servidor, simplemente hay que añadirle un módulo.
            </p>

            <p>
              Los módulos base y multiproceso más importantes son:
            </p>
              <ul>
                <li><b>core</b>: Funciones básicas de Apache que están disponibles.</li>
                <li><b>mpm_common</b>: Colección de directivas que se implementan en más de un módulo multiproceso.</li>
                <li><b>beos</b>: Módulo de multiproceso optimizado para BeOS.</li>
                <li><b>leader</b>: Variable experimental de MPM.</li>
                <li><b>mpm_netware</b>: Módulo de multiproceso que implementa un servidor web optimizado para Novell NetWare.</li>
                <li><b>mpmt_os2</b>: MPM híbrido, multiproceso y multihilo para OS/2.</li>
                <li><b>perchild</b>: Módulo multiproceso que permite a los procesos demonio servir las peticiones que se asignan a distintos ID de usuario.</li>
                <li><b>prefork</b>: Implementa un servidor sin hilos.</li>
                <li><b>threadpool</b>: Variante experimental del módulo estándar de MPM.</li>
                <li><b>mpm_winnt</b>: Módulo multiproceso optimizado para Windows NT.</li>
                <li><b>worker</b>: Módulo multiproceso que implementa un híbrido multihilos y multiprocesos de servidor Web.</li>
              </ul>

            <p>
              Los módulos adicionales más destacables son los siguientes:
            </p>
              <ul>
                <li><b>mod_access</b>: proporciona control de acceso basándose en el nombre del host del cliente, su dirección IP u otras características de la petición del cliente.</li>
                <li><b>mod_actions</b>: se utiliza para ejecutar scripts CGI, basándose en el tipo de medio o el método de petición.</li>
                <li><b>mod_alias</b>: permite mapear diferentes partes del sistema de ficheros del servidor en el árbol de documentos del servidor, y para redirección de URLs.</li>
                <li><b>mod_asis</b>: Envío de ficheros que tienen sus propias cabeceras http.</li>
                <li><b>mod_auth</b>: Autentificación de usuario utilizando ficheros de texto.</li>
                <li><b>mod_auth_anon</b>: Permite a usuarios anónimos acceder a áreas autentificadas.</li>
                <li><b>mod_auth_dbm</b>: Autentificación utilizando ficheros DBM.</li>
                <li><b>mod_auth_digest</b>: Autentificación de usuario utilizando MD5.</li>
                <li><b>mod_auth_ldap</b>: Permite la utilización de un directorio LDAP para almacenar la base de datos de autentificación.</li>
                <li><b>mod_autoindex</b>: muestra los contenidos de un directorio automáticamente, paracido al comando <code>ls</code> de Unix.</li>
                <li><b>mod_cache</b>: Cache de contenidos indexados por URIs.</li>
                <li><b>mod_cern_meta</b>: Semántica de etiquetas meta del CERN.</li>
                <li><b>mod_cgi</b>: Ejecución de Scripts CGI.</li>
                <li><b>mod_cgid</b>: Ejecución de scripts CGI utilizando un demonio CGI externo.</li>
                <li><b>mod_charset_lite</b>: Para la especificación del juego de caracteres de las traducciones.</li>
                <li><b>mod_deflate</b>: comprime el contenido antes de ser enviado al cliente.</li>
                <li><b>mod_dir</b>: Proporcionado para redirecciones y para servir los ficheros de listado de directorios.</li>
                <li><b>mod_disk_cache</b>: Cache para almacenar contenidos indentificados por URI.</li>
                <li><b>mod_echo</b>: Servidor simple de echo para ilustrar los módulos del protocolo.</li>
                <li><b>mod_env</b>: Modificación del entorno que se envía a los scripts CGI y a las páginas SSI.</li>
                <li><b>mod_expires</b>: Generación de las cabeceras HTTP Expires, de acuerdo a los criterios especificados por el usuario.</li>
                <li><b>mod_ext_filter</b>: Pasa el cuerpo de la respuesta a través de un programa antes de enviársela al cliente.</li>
                <li><b>mod_file_cache</b>: Cachea una lista estática de ficheros en memoria.</li>
                <li><b>mod_headers</b>: Personalización de las peticiones HTTP y las cabeceras de las respuestas.</li>
                <li><b>mod_imap</b>: Proceso de imágenes en el lado del servidor.</li>
                <li><b>mod_include</b>: Documentos HTML generados por el servidor (Server Side includes)</li>
                <li><b>mod_info</b>: Proporciona una visión comprensiva de la configuración del servidor.</li>
                <li><b>mod_isapi</b>: Extensiones ISAPI en Apache para Windows.</li>
                <li><b>mod_idap</b>: pool de conexiones LDAP y cacheo de resultados para la utilización de otros módulos LDAP.</li>
                <li><b>mod_log_config</b>: Registro de las peticiones hechas al servidor.</li>
                <li><b>mod_logio</b>: Registro del número de bytes recibidos y enviados en cada respuesta.</li>
                <li><b>mod_mem_cache</b>: Cache de contenidos identificados por URI.</li>
                <li><b>mod_mime</b>: Asocia las extensiones de peticiones de los ficheros con el comportamiento del fichero (manejadores y filtros) y contenido (tipos mime, idioma, juego de caracteres y codificación)</li>
                <li><b>mod_mime_magic</b>: Determina el tipo MIME de un fichero mirando unos pocos bytes del contenido.</li>
                <li><b>mod_negotiation</b>: Se proporciona para la negociación del contenido.</li>
                <li><b>mod_proxy</b>: Servidor HTTP/1.1 proxy/gateway</li>
                <li><b>mod_proxy_connect</b>: Extensión de mod_proxy para la gestión de las peticiones CONNECT.</li>
                <li><b>mod_proxy_ftp</b>: Soporte FTP para mod_proxy</li>
                <li><b>mod_proxy_http</b>: Siporte HTTP para el módulo mod_proxy</li>
                <li><b>mod_rewrite</b>: Proporciona un motor de reescritura basado en reglas que rescribe las peticiones de URLs al vuelo.</li>
                <li><b>mod_setenvif</b>: Permite la configuración de las variables de entorno basándose en las características de la petición.</li>
                <li><b>mod_so</b>: Carga el código ejecutable y los módulos al iniciar o reiniciar el servidor.</li>
                <li><b>mod_speling</b>: Intenta corregir las URL mal puestas por los usuarios, ignorando las mayúsculas y permitiendo hasta una falta.</li>
                <li><b>mod_ssl</b>: Criptografía avanzada utilizando los protocolos Secure Sockets Layer y Transport Layer Security.</li>
                <li><b>mod_status</b>: Proporciona información en la actividad y rendimiento del servidor.</li>
                <li><b>mod_suexec</b>: Permite a los scripts CGI ejecutarse con un nombre y grupo específico.</li>
                <li><b>mod_unique_id</b>: Proporciona variables de entorno y un identificador único para cada petición.</li>
                <li><b>mod_userdir</b>: Directorios específicos para usuarios.</li>
                <li><b>mod_usertrack</b>: Registro de actividades de un usuario en el sitio.</li>
                <li><b>mod_vhost_alias</b>: Proporcionado para configurar muchos servidores virtuales dinámicamente.</li>
              </ul>

          <h3>Páginas dinámicas</h3>
            <p>
              HTML no es un lenguaje de programación, es sólo un lenguaje descriptivo que tiene como objeto dar formato al texto y las imágenes que se pretenda visualizar en un navegador.
            </p>
            <p>
              Sin embargo, existen lenguajes que son capaces de responder de manera inteligente a las demandas del navegador y que permiten la automatización de tareas tediosas e intermediables como peuden ser las actualizaciones, el acceso a base de datos, etc. Estos lenguajes permiten desarrollar <b>páginas dinámicas</b>.
            </p>

            <p>
              Los lenguajes de lado servidor más ampliamente utilizados para el desarrollo de páginas dinámicas son el ASP, PHP y PERL. ASP es un lenguaje derivado del Visual Basic desarrollado por Microsoft, por lo que son adecuados para plataformas bajo sistema Windows NT. El PHP es un lenguaje análogo a ASP, pero utilizado en plataformas UNIX y Linux. PERL es un lenguaje más rápido y potente.
            </p>

            <p>
              El uso de páginas estáticas o dinámicas dependerá de la funcionalidad que se desee tener. Una página relativamente pequeña, que no necesite estar al día contínuamente ya que sus contenidos son fijos y no se tiene previsto pagar por mantenerla, puede desarrollarse en HTML. Sin embargo, si el sitio web es extenso y sus contenidos van a ir cambiando rápidamente, será necesario automatizar en la medida de lo posible todas las tareas.
            </p>

          <h3>PHP</h3>
            <p>
              PHP es el lenguaje más utilizado en la Web para la realización de páginas avanzadas por ser potente y estable. Una de sus características, es que permite una programación orientada a objetos.
            </p>

            <p>
              <b>PHP</b> es un lenguaje interpretado similar a JavaScript que se ejecuta en el lado del servidor y permite la creación de documentos y páginas Web con contenido dinámico.
            </p>

            <p>
              Al estar, el código PHP empotrado dentro de un documento HTML, cuando un usuario desde su navegador hace clic sobre un enlace correspondiente a un documento HTML que incluye código PHP, el navegador realiza la solicitud al servidor Web correspondiente, el servidor localiza el documento, detecta que se trata de una página PHP y pone en funcionamiento el intérprete que tiene del lenguaje que ejecuta el código PHP.
            </p>

            <p>
              La forma más habitual de introducir código PHP en un documento HTML, es con la cadena de inicio y final:
            </p>

            <pre><br><code>&lt;?php ... ?&gt;</code><br>   <code>&lt;? ... ?&gt;</code>
            </pre>

            <p>
              Para instalar los módulos para soporte de PHP5 en Apache, primero hay que detener Apache, después se edita el archivo <code>httpd.conf</code>. La ruta del lado derecho de la sentencia <code>LoadModule</code> debe indicar dónde está el módulo de PHP en el sistema. Estas series deben de estar seguidas unas de otras.
            </p>

            <pre><br><code>LoadModule [apache_route]</code>
            </pre>

            <p>
              Para hacer que Apache responda a las extensiones de archivo PHP, en el mismo archivo se incluye la siguiente línea de comando:
            </p>

            <pre><br><code>AddType application/x-httpd-php .php .phtml</code>
            </pre>

            <p>
              Finalmente se arranca Apache con el procedimiento normal.
            </p>

            <p>
              Para hacer una prueba de funcionamiento con un editor de texto el código: <code>&lt;?php phpinfo(); ?&gt;</code> y se guarda el archivo con el nombre <code>prueba.php</code> en el directorio <code>/var/www/html</code> o en la carpeta <code>htdocs</code>. Finalmente se realiza la prueba introduciendo la siguiente dirección en el navegador: <i>http://localhost/prueba.php</i>, con esto se debería visualizar una página de prueba.
            </p>

          <h3>Configuración Básica de Apache</h3>
            <p>
              La configuración de Apacha se realiza mediante la modificación del archivo <code>httpd.conf</code>. La estructura de este fichero se compone de tres bloques fundamentales, aunque las directivas de cada uno de ellos puedan aparecer desordenadas o mezcladas. Estos bloques son:
            </p>
              <ul>
                <li>Parámetros globales.</li>
                <li>Directivas de funcionamiento.</li>
                <li>Host virtuales.</li>
              </ul>

            <p>
              Algunos parámetros son de propósito general y otros son configurables de forma independiente para cada conjunto de directorios o archivos, e incluso para un servidor virtual específico. Estos parámetros se encuentran dentro de desecciones en las que se indica el contexto de aplicación de dicho parámetro. Algunas secciones son:
            </p>
              <ul style="list-style: none;">
                <li><b>&lt;Directory&gt;</b>: Los parámetros que se encuentran dentro de esta sección sólo se aplican al directorio indicado y sus subdirectorios.</li>
                <li><b>&lt;Files&gt;</b>: Los parámetros de configuración facilitan el control de acceso a los archivos mediante su nombre.</li>
                <li><b>&lt;VirtualHost&gt;</b>: Los parámetros sólo se aplican a aquellas peticiones dirigidas a este host (nombre de servidor, dirección IP o puerto TCP)</li>
              </ul>
            <p>
              En cuanto a &lt;VirtualHost&gt;, estas directivas se aplican después de las directivas generales. De este modo, un VirtualHost puede modificar la configuración por defecto.
            </p>

            <p>
              Algunas directivas de configuración nunca se aplcian a las secciones como directorio, sino que afectan al conjunto del servidor Web. Las más destacables son:
            </p>
              <ul>
                <li><b>ServerRoot</b>: especifica la localización del directorio raíz en el que se encuentra instalado el servidor.</li>
                <li><b>Listen</b>: especifica el puerto en que se deben utilizar conexiones persistentes. Por defecto el servidor "escucha" en el puerto 80 de TCP.</li>
              </ul>

            <p>
              En el momento de la configuración hay una serie de directivas que generalmente no suelen aparecer en las secciones mencionadas, sino que se encuentran en la sección principal. Estas directivas son:
            </p>
              <ul>
                <li>ServerAdmin</li>
                <li>ServerName</li>
                <li>DocumentRoot</li>
                <li>mod_access</li>
                <li>Allow</li>
                <li>Deny</li>
                <li>Order</li>
              </ul>

          <h3>Archivos de configuración principales</h3>
            <p>
              Como ya se indicó, la configuración de Apache se realiza a través del archivo de configuración principal <code>httpd.conf</code>
            </p>

            <p>
              Por otro lado, se pueden añadir otros archivos de configuración utilizando la directiva <code>include</code>. En estos archivos de configuración se podrá incluir cualquier directiva. Los cambios en los archivos principales de configuración son reconocidos solamente cuando Apache es arrancado y reiniciado.
            </p>

            <p>
              Apache también lee un archivo que contiene los tipos mime de documentos. El nombre del archivo es puesto por la directiva <code>TypesConfig</code> y su nombre por defecto es <code>mime_types</code>
            </p>

            <p>
              Los archivos <b>.htaccess</b> es un archivo de texto que Apache usa para disponer de una serie de directivas. Las directivas que se pongan dentro de estos ficheros se aplicarán unicamente al directorio donde esté ubicado y a todos sus subdirectorios. El contenido de este tipo de ficheros habilita al servidor a comportarse de una determinada manera, como por ejemplo optimizar una URL ocultando las variables pasadas por la misma, el bloqueo de usuarios, el control de tráfico de una Web, definir una página de inicio diferente, crear un mensaje de error personalizado, etc.
            </p>

            <p>
              Las secciones de configuración más utilizadas son aquellas que cambian la configuración de lugares particulares en el sistema de archivos o el espacio Web. Este punto hace referencia a la transacción que se efectúa desde la interpretación de los datos por parte del servidor ahsta su interpretación Web por parte del usuario.
            </p>

            <p>
              El <b>sistema de archivos</b> es la vista de los discos tal cual los ve el sistema operativo, por ejemplo la instalación por defecto de Apache está en <code>/usr/local/apache2</code>.
            </p>

            <p>
              El <b>espacio Web</b> (WebSpace) es la vista de nuestro sitio mostrada por el servidor Web y cómo es visto por el cliente.
            </p>

            <p>
              Por lo tanto la ruta de acceso <code>/dir/</code> en el espacio Web corresponde a la ruta de acceso <code>/usr/local/apache2/htdocs/dir/</code> en el sistema de archivos de una instalación por defecto de Apache.
            </p>

            <p>
              Las directivas &lt;Directory&gt; y &lt;Files&gt; se aplican a partes del sistema de archivos. Las directivas encerradas en una sección <code>&lt;Directory&gt;</code> se aplican en el mismo directorio del sistema de archivos nombrado y a todos los subdirectorios del mismo. El mismo efecto puede ser obtenido usando los archivos <code>.htaccess</code>.
            </p>

            <p>
              Por ejemplo para que los índices del directorio sean activados para el sistema de archivos que se indica, así como también para sus subdirectorios, se escribe:
            </p>

            <pre><br/><code>&lt;Directory /var/web/dir1&gt;<br/>  Options +Indexes <br/>&lt;/Directory&gt;</code>
            </pre>

            <p>
              Aquellas directivas encerradas en una sección <code>&lt;Files&gt;</code> se aplican a todo archivo con el nombre especificado sin importar en que directorio se encuentre.
            </p>

            <p>
              Por ejemplo las siguientes directivas de configuración, cuando se coloquen en la sección principal de configuración, denegarán el acceso a cualquier archivo llamado privado.html sin importar donde se encuentre.
            </p>

            <pre><br/><code>&lt;Files privado.html&gt;<br/>  Order allow,deny <br/>  Deny from all <br/>&lt;/Files&gt;</code>
            </pre>

            <p>
              Para dirigirse a archivos encontrados en un lugar particular del sistema de archivos, las secciones &lt;Files&gt; y &lt;Directory&gt; pueden combinarse. Por ejemplo la siguiente configuración denegará el acceso a cualquier instancia de privado.html encontrada bajo el directorio indicado.
            </p>

            <pre><br/><code>&lt;Directory /var/web/dir1&gt; <br/>&lt;Files privado.html&gt;<br/>  Order allow,deny <br/>  Deny from all <br/>&lt;/Files&gt;&lt;/Directory&gt;</code>
            </pre>

            <p>
              La directiva <code>Location</code>, por un lado es una regex y por otro cambia la configuración del contenido del espacio Web. Las <b>regex</b> o <b>expresiones regulares</b> son una forma de describir un modelo de texto, por ejemplo "todas las plabras que empiezen con la letra 'R'", y que permiten generar filtros para expresiones de todo tipo. Las expresiones regulares son útiles en Apache porque permiten aplicar ciertos atributos a colecciones de ficheros o recursos de una forma flexible.
            </p>

            <p>
              Por ejemplo todos los archivos <i>.gif</i> y <i>.jpg</i> que estén en un directorio "imagenes" pueden ser escritos con la expresión regular: <code>/imagenes/.*(jpg|gif)$</code>
            </p>

            <p>
              Para elegir entre contenedores de sistemas de archivos y espacios Web, es importante considerar: Cuando se aplican directivas a objetos que residen en el sistema de archivos siempre se usan <code>Directory</code> o <code>Files</code> y cuando las directivas se aplican a objetos que no residen en el sistema de archivos, como páginas Web generadas por base de dados, se usa <code>Location</code>.
            </p>

            <p>
              Es importante que se use <code>Location</code> cuando se trata de restringir el acceso a objetos que residen en el sistema de archivos. Esto se debe a que muchas localizaciones diferentes del Webspace (URLs) pueden dirigirse (map) al mismo lugar del sistema de archivos, permitiendo que las restricciones sean evitadas. Como en el ejemplo siguiente:
            </p>

            <pre><br/><code>&lt;Location /private&gt; <br/>  Order allow,deny <br/>  Deny from all <br/>&lt;/Location&gt;</code>
            </pre>

          <h3>Servidores virtuales</h3>
            <p>
              Un <b>servidor virtual</b> es aquel que permite mantener distintos trabajos a la vez y, dentro de estos, facilitar su acceso mediante un nombre de dominio en lugar de por su ruta habitual. Por ejemplo se podría acceder al lugar Web <i>/localhost/proyectos</i> o acceder por su nombre de domio, es decir: <i>www.proyectos.com</i> directamente. Es importante distinguir entre dos tipos de servidores virtuales: los servidores de nombres y los servidores de IP.
            </p>

            <p>
              La configuración para host virtuales se adapta dependiendo de lo que se necesite. Si se configura Apache para soportar servidores por dirección de nombres entonces se pasa como parámetro el número de IP correspondiente: <code>&lt;VirtualHost 168.264.1.3&gt;</code>.
            </p>

            <p>
              Si lo que se prefiere es un servidor de nombres entonces se pasa como parámetro el puerto 80 de la máquina para liberarlo completamente y que atienda cualquier tipo de solicitudes provenientes de distintos clientes: <code>&lt;VirtualHost *:80&gt;</code>. Al colocar el asterisco (*), no habrá restricciones a las máquinas que hagan solicitudes por nombre, pero si se utiliza una dirección IP concreta, en su lugar se puede asignar ésta por nombre y otras por IP.
            </p>

            <p>
              Los servidores virtuales que distinguen en función del nombre son perfectamente transparantes para el cliente. El hosting virtual basado en nombres necesita de la configuración del servidor de DNS para que localice las direcciones IP correctas. Después será necesario configurar Apache para que reconozca diferentes nombres de host.
            </p>

          <h3>Configuración de Apache para soporte de virtualhost</h3>
            <p>
              El servidor se configura para el trabajo con virtualhosts con la adición de algunas líneas de comando al archivo <code>httpd.conf</code>, son las siguientes:
            </p>
              <ul>
                <li><b>&lt;VirtualHost&gt;</b> Especifica dónde y en qué puerto se va a levantar el nuevo dominio o subdominio</li>
                <li><b>ServerAdmin</b>: Corresponda al e-mail de la persona de contacto para este dominio. Es vital cuando tenemos un ISP o administramos una gran cantidad de dominios para los cuales se da la dirección de contacto de la persona responsable.</li>
                <li><b>DocumentRoot</b>: Es la raíz donde se deben ubicar los índices del nuevo sitio.</li>
                <li><b>ScriptAlias</b>: En este directorio especificado por un alias será donde se ejecuten los Scripts, por ejemplo archivos PERL.</li>
                <li><b>ServerName</b>: Es donde se decreta el nombre real del dominio. Es el mismo que se utiliza en el DNS como cname.</li>
              </ul>

            <p>
              Los parámetros anteriores pueden utilizarse en el archivo de configuración, como en el siguiente ejemplo:
            </p>
      

              <ul>
                <li>NameVirtualHost *:80 seguido de la dirección IP para usar hosting virtual basado en nombres.</li>
                <li>&lt;VirtualHost&gt;, la etiqueta VirtualHost seguida del nombre que se acaba de especificar</li>
                <li>ServerName www.prueba.com seguido del nombre de host y número de puerto que el servidor usa para indentificarse.</li>
                <li>ServerAlias prueba.com *.prueba.com seguido de los nombres alternativos usados para un host cuando se intentan encontrar equivalencias a hosts virtuales basados en el nombre.</li>
                <li>DocumentRoot /www/domain seguido de la ruta de acceso a los proyectos (htdocs o html)</li>
              </ul>

            <pre><br/><code>NameVirtualHost *:80 <br/>&lt;VirtualHost *:80&gt; <br/>  ServerName www.prueba.com *.prueba.com <br/>  DocumentRoot /www/domain <br/> &lt;/VirtualHost&gt;</code>
            </pre>

            <p>
              Para verificar si la configuración es correcta, se abre un navegador y en lugar de colocar la ruta de acceso al sitio (http://localhost/prueba) se escribe el nombre del dominio (http://www.prueba.com). Con esto se deberá ver el contenido de la carpeta htdocs o html, dependiendo del caso.
            </p>

          <h3>Usuarios y grupos</h3>
            <p>
              La creación de usuarios y grupos surgen de la necesidad de que las páginas Web puedan ser leídas por gran cantidad de visitantes, pero que no puedan tener acceso a su configuración, diseño o a la modificación del contenido.
            </p>

            <p>
              El control de usuarios también tiene sentido si se desea proporcionar un servicio de hosting de pago. En estos casos el panel de control Web, debe permitir subir, eliminar, crear base de datos, etc, pero no debe de estar abierto al público. Este problema se soluciona mediante un sistema de login que identifique al usuario que accede al servicio y una password que lo valide. Por lo general, el envío de esta información se realiza mediante un encriptado que garantiza la integridad de los datos.
            </p>

            <p>
              El sistema de encriptado no se puede ver ya que es totalmente transparente a los usuarios. Por otra parte, la gran mayoría de los servicios como el e-mail, utilizan algún método de seguridad. El más común de los protocolos de transferencia segura es el simple mail o SMTP.
            </p>

            <p>
              Una ventaja del servidor Apache consiste en que, con total independencia del sistema operativo, es capaz de crear y modificar la lista de usuarios que tendrán acceso a una página determinada. Para este fin, se debe de indicar en que archivo se debe buscar los usuarios y cuál va a ser la raíz del directorio protegido en <code>httpd.conf</code>:
            </p>

            <pre><br/><code>&lt;Directory /usr/local/apache2/htdocs/protectsite&gt; <br/>  AllowOverride None <br/>  AuthName "Attack ADM Page" <br/>  AuthType Basic <br/>  AuthUserFile /usr/local/apache2/conf/.htpasswd <br/>  require valid-user <br/>&lt;/Directory&gt;</code>
            </pre>

          <h3>Autentificación</h3>
            <p>
              Al implementar la gestión de usuarios, el servidor lleva a cabo acciones con el fin de autentificar el usuario, y una vez se confirme su identidad, sirve la petición y permite el acceso. Estas acciones para verificar la validez del usuario o de la aplicación que quiere acceder pueden clasificarse en: autenticación, autorización y control de acceso. Estas configuraciones requieren de la directiva <code>AllowOverride</code> con el valor <code>AuthConfig</code>
            </p>

            <p>
              Para configurar el servidor apache y que sea capaz de autentificar a los usuarios y verificar la autorización del mismo al recurso solicitado, es necesario realizar las siguientes acciones:
            </p>
              <ol>
                <li>Crear un archivo de usuarios.</li>
                <li>Crear un archivo de grupos (si es necesario).</li>
                <li>Definir las directivas en el fichero de configuración o mediante un fichero .htaccess</li>
              </ol>

            <p>
              Estos archivos se generan automáticamente después de añadir las directivas necesarias y reiniciar Apache. Si no es necesario, se tiene que buscar y configurar manualmente.
            </p>

            <p>
              Sólo el superusuario o root debe estar autorizado para llevar a cabo las modificaciones de los archivos contenedores de usuarios y grupos.
            </p>

            <p>
              Las directivas de <code>mod_auth</code> necesarias para configurar la autentificación y autorización son las siguientes:
            </p>
              <ul>
                <li><b>AuthUserFile</b>: sirve para especificar la ruta donde se almacenará el fichero de usuarios.</li>
                <li><b>AuthGroupFile</b>: sirve para especificar la ruta donde se almacenará el fichero de grupos.</li>
              </ul>

            <p>
              Existen dos métodos que permite Apache para acceder a cierto directorio a través de un usuario y clave:
            </p>
              <ul>
                <li><b>Basic</b>: cuando el cliente introduce el usuario y clave, estos datos viajan al servidor sin cifrar. Es recomendable para archivos de poca importancia, cuyo acceso sólo se restringe para mantener el control sobre los usuarios que los modifican y así evitar conflictos.</li>
                <li><b>Digest</b>: el usuario y la clave van cifrados del cliente al servidor. Esto brinda mayor seguridad, debido a que si la clave es capturada por algún usuario no autorizado, ésta será ininteligible.</li>
              </ul>

            <p>
              Los métodos sólo sirven para autentificar a un usuario cuando intenta acceder a un determinado recurso, una vez que se identifica un usuario válido se deja acceder al recurso, pero los datos que posteriormente se envian del cliente al servidor, o viceversa, no tienen ningún tipo de cifrado. Por lo tanto, estos métodos sólo sirven para controlar el acceso, no para proteger los datos una vez se ha comprobado que el acceso es válido.
            </p>

            <p>
              Para configurar la autontificación, se modifica el archivo <code>httpd.conf</code>
            </p>

            <pre><br/><code>&lt;Directory "var/www/html/private"&gt; <br/>  AuthName "privatefiles" <br/>  AuthType Basic <br/>  AuthUser File /etc/httpd/conf/passwd_basic <br/>  Require valid-user <br/>&lt;/Directory&gt;</code>
            </pre>

            <ul>
              <li><b>&lt;Directory "ruta_de_directorio"&gt;</b>, se indica la ruta del directorio que se va a proteger. Suele ser una buena idea generar una carpeta /private. Todas las directivas que se escriben a continuación afectarán a este directorio.</li>
              <li><b>AuthName "privatefiles"</b> seguido del nombre de autentificación. También es el texto que aparece en la ventana que solicitará el usuario y clave.</li>
              <li><b>AuthType Basic</b> seguido del tipo de autentificación.</li>
              <li><b>AuthUser File /etc/httpd/conf/passwd_basic</b> seguido del nombre del archivo donde están los usuarios y las claves.</li>
              <li><b>Require valid-user</b>, con esta directiva se indica que usuarios tienen acceso.</li>
            </ul>

            <p>
              Parar crear los usuarios con el método de autenticación Basic, se usa la aplicación <code>htpasswd</code>. Si el archivo no existe (porque es la primera vez que se crea un usuario), es necesario lanzar el comando con la opción <code>-c</code>
            </p>

            <pre><br/><code># ./htpasswd -c /etc/httpd/conf/passwd_basic usuario</code>
            </pre>

            <p>
              Para especificar la clave en la línea de comandos se utiliza la opción <code>-b</code>:
            </p>

            <pre><br/><code># ./htpasswd -b /etc/httpd/conf/passwd_basic usuario clave</code>
            </pre>

            <p>
              Para especificar gurpos de usuario que serán autentificados, basta con crear un archivo de texto con el siguiente formato para cada línea: <code>nombreGrupo: user1 user2 user3 ...</code>. Después se utiliza la directiva <code>AuthGroupFile</code> para indicar la ruta completa donde se encuentra el fichero que se ha creado con la definición de grupos. Cada usuario del grupo se añade al fichero de claves como se detalló anteriormente.
            </p>

          <h3>Ejemplo de Host Virtual y credencial de acceso</h3>
            <p>
              Si se quiere crear un host virtual para Apache y establecer una credencial de acceso para acceder al directorio Web, con las siguientes características:
            </p>
              <ul>
                <li>Dominio a alojar en el host virtual: www.dominiovirtual.com</li>
                <li>Directorio de la Web del host virtual: /var/www/dominiovirtual.com</li>
                <li>Correo de contacto del WebMaster: webmaster@dominiovirtual.com</li>
                <li>Usuario para acceder a la Web: admin</li>
                <li>Contraseña para acceder a la Web: unaclave</li>
                <li>Archivo donde se almacenará las credenciales de acceso: /etc/apache2/conf/dominiovirtual.com-passwd</li>
                <li>Mensaje que aparecerá al solicitar la credencial para acceder: "Mensaje de acceso a dominiovirtual.org"</li>
              </ul>

            <p>
              En primer lugar se tiene que crear el host virtual, modificando el archivo de configuración de Apache 2:
            </p>

            <pre><br/><code>NameVirtualHost *:80 <br/>&lt;VirtualHost *:80&gt; <br/>  ServerName www.dominiovirtual.com <br/>  ServerAdmin webmaster@dominiovirtual.com <br/>  DocumentRoot /var/www/dominiovirtual.com <br/>  AuthName "Mensaje de acceso a dominiovirtual.org" <br/>  AuthType Basic <br/> AuthUserFile /etc/apache2/conf.d/dominiovirtual.com-passwd <br/>  AuthGroupFile /dev/null <br/>  Require user admin <br/>&lt;/VirtualHost&gt;</code>
            </pre>

            <p>
              Posteriormente se debe validar el nombre de dominio especificado en ServerName.
            </p>

            <p>
              A continuación se procede a crear un archivo de usuarios, y debido a que se realiza por primera vez se utiliza el parámetro -c.
            </p>

            <pre><br/><code># htpasswd -c /etc/httpd/conf/passwd_basic usuario <br/>New password: <br/>Re-type new password: <br/>Adding password for user admin</code>
            </pre>



        <h2>Proxy</h2>
          <p>
            Un <b>proxy</b> es un dispositivo o sistema intermediario que hace de pasarela entre el tráfico que recibe o envía y la red.
          </p>

          <p>
            Los proxys "cache para Web" se utilizan para auditar y guardar las peticiones que se han hecho una página Web.
          </p>

          <p>
            El <b>Proxy Caché Web Squid</b>, permiter hacer el cacheo de las páginas que se visitan en una red, así como la definición de un determinado control de acceso. Con esto, se limita el acceso al proxy para que sólo determinadas máquinas puedan usarlo.
          </p>
          
          <p>
            Otro aspecto primordial del proxy es el aislamiento del acceso a Internet, de forma que únicamente se pueda acceder a través del proxy. En el caso de Squid, al ser únicamente un "proxy caché Web", sólo hace de intermedio de los protocolos HTTP y HTTPS.
          </p>

          <h3>Instalación del Proxy</h3>
            <p>En una distribución Fedora, y utilizando yum, la instaiacón del servicio de Squid se realiza:</p>
            <pre>
              <code># yum install squid</code>
            </pre>

            <p>
              Para arrancar el servicio se utiliza el comando:
            </p>
            <pre>
              <code># service squid start</code>
            </pre>

            <p>
              Si el servicio ya está arrancado, se devuelve un error. En este caso, es recomendable reiniciar el servicio. Para hacerlo se utiliza el comando:
            </p>
              <pre>
                <code># service squid restart</code>
              </pre>

            <p>
              Por defecto, Squid funciona en el puerto 3128.
            </p>

          <h3>Configuración de Squid</h3>
            <p>
              La configuración de Squid se realiza modificando el fichero <code>/etc/squid/squid.conf</code>
            </p>

            <p>
              Squid permite definir las <b>conexiones anónimas</b>, mediante la modificación de las cabeceras del protocolo http, para que se desconozca información del cliente.
            </p>

            <p>
              Las cabeceras <b>header_access</b> y <b>header_replace</b> permiten definir reglas de acceso para determinados clientes.
            </p>

            <p>
              Para poder cachear los contenidos, se debe activar la opción <code>cache_mem N MB</code>, donde N MB es el tamaño de caché para guardar todas las páginas que se visite. Esto permite controlar las peticiones que se haga a diferentes servidores externos, guardando las visitas en caché con un tamaño máximo correspondiente al asignado.
            </p>

            <p>
              Para habilitar el uso de la caché, se debe de ejecutar squid con la opción -z. Ejecutando el comando:
            </p>
              <pre>
                <code># /usr/bin/squid -z</code>
              </pre>

            <p>
              Es posible que también sea necesario configurar un <b>proxy reverso</b> o <b>acelerador Web</b>. Es decir, configurarlo para que las respuestas a los clientes también se guarden en la memoria caché.
            </p>

            <p>
              Suponiendo que se cuenta con un servidor llamado "miservidor.com" y que "misquid.com" es un servidor caché acelerador. La primera vez que se visite "miservidor.com" se guardará la caché en "misquid.com".
            </p>

            <p>
              Para configurar la aceleración, el fichero de configuración debe tener las siguientes directivas:
            </p>
            <pre>
                <code><br/>http_port 80 <br/>httpd_accel_host 172.16.1.115 <br/>httpd_accel_port 80 <br/>httpd_accel_single_host on <br/>httpd_accel_with_proxy on <br/>httpd_accel_uses_host_header off</code>
            </pre>

            <p>
              La configuración anterior indica que el puerto del proxy es el 80, que la IP de "miservidor.com" es la 172.16.1.115 que se corresponde también con el puerto 80. Además se activa los servicios de aceleración. Con esto, se tiene configurado correctamente un accelerador Web para un servidor.
            </p>

            <p>
              El funcionamiento de la caché y de la aceleración es sencillo: en las siguientes consultas que se haga en la red se guardará una copia de las peticiones para que, en los proximos accesos se libre a la máquina de infinidad de tareas y tráfico de archivos.
            </p>

          <h3>Control de Acceso en Squid</h3>
            <p>
              Para definir <b>reglas de acceso</b> o <b>ACL</b>s para Squid, se debe editr el fichero de configuración de squid y establecer la política de acceso, a través de la directiva <code>http_access</code>.
            </p>

            <p>
              Si por ejemplo se quiere denegar el acceso a localhost, y permitir el rango de red de la 192.168.1.0 y la 192.168.2.0. Es decir, las dos redes privadas que se tiene en la red de oficina o casa, el fichero /etc/squid/squid.conf contendrá:
            </p>

            <pre>
              <code><br/># relaxed_header_parser on <br/>http_access deny to_localhost <br/>acl our networks src 192.168.1.0/24 192.168.2.0/24 <br/>gttp access allow our_networks</code>
            </pre>

            <p>
              La aplicación <b>SquidGuard</b> utiliza listas de acceso basada en contenidos. Por ejemplo, tiene definidas listas para contenidos adultos, páginas de hacking, de pago, etc.
            </p>

          <h3>Configuración de los clientes</h3>
            <p>
              Por ejemplo, para comprobar que la configuración de Squid del punto anterior es la correcta, see abre un navegador en una máquina de la red 192.168.1.0, y en configuración de conexión se coloca la IP de la máquina que contiene el Squid y su puerto (por defecto, 3128).
            </p>
            <p>
              Finalmente, se realiza una petición de una Web para comprobar si funciona la salida a Internet a través del proxy
            </p>


        <h2>Firewall</h2>
          <p>
            Un <b>firewall</b> es un sistema de protección que se encarga de definir reglas de aceptación o denegación de tráfico de red.
          </p>

          <p>
            Mediante el uso del firewall, se puede definir accesos y bloqueos desde el nivel 2 al nivel 5 de las diferentes capas de red.
          </p>

          <p>
            La configuración de un firewall dependerá del sistema de conexión que se tenga. Las reglas de bloqueo serán más exigentes para un router que para un ordenador de casa.
          </p>

          <h3>Firewall en Linux</h3>
            <p>
              El firewall en Linux se conoce como <b>iptables</b>. Linux define cinco cadenas que se encargan de definir el tipo de tráfico: INPUT, OUTPUT, FORWARD, POSTROUTING y PREROUTING.
            </p>

            <p>
              Por ejemplo, la cadena INPUT indica tráfico de entrada, es decir, el tráfico de red que lelga a nuestra máquina. Por lo que si alguien se conecta por SSH, se tiene que aceptar por la cadena de entrada el tráfico de red del puerto 22, el correspondiente a SSH.
            </p>

            <p>
              Si se quiere conectar a ver una página Web, el firewall tiene que aceptar paquetes de salida de la capa OUTPUT.
            </p>

          <h3>Políticas de un firewall</h3>
            <p>
              A la hora de configurar un firewall se puede definir dos tipos de políticas: aceptación o denegación. Estas políticas se realizan sobre una cadena específica de la configuración del firewall.
            </p>

            <p>
              Para listar las reglas de todas las cadenas:
            </p>
              <pre><code># iptables -L</code></pre>

            <p>
              Para pasar a DROP las conexiones de entrada y salida:
            </p>
              <pre><code># iptables -P INPUT DROP<br/># iptables -P OUTPUT DROP</code></pre>              

            <p>
              Para pasar a ACCEPT las conexiones de entrada y salida:
            </p>
              <pre><code># iptables -P INPUT ACCEPT<br/># iptables -P OUTPUT ACCEPT</code></pre>


          <h3>Configuración de iptables</h3>  
            <p>
              La sintaxis para habilitar puertos es:
            </p>
              <ul>
                <li><b>-A</b> añade a una cadena una regla, ya sea INPUT u OUTPUT, para el tráfico de entrada o salida respectivamente</li>
                <li><b>-p</b> especifica el tipo de protocolo, tcp, udp</li>
                <li><b>--dport</b> especifica el puerto destino de cada protocolo</li>
                <li><b>-j</b> especifica que hacer con esta regla, ACCEPT para aceptar el tráfica, o DROP o REJECT para denegarlo</li>
              </ul>

            <p>
              Supongamos que se precisa de un firewall para nuestro sistema. Si se cuenta con varios servicios, entre estos con SSH para el acceso remoto y con un servicio FTP., se impone las reglas input para el puerto 22 SSH tcp y para el puerto 21 FTP tcp.
            </p>
              <pre><code># iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br/># iptables -A INPUT -p tcp --dport 21 -j ACCEPT</code></pre>

            <p>
              En el caso del acceso al exterior. Si se busca tener acceso web (HTTP), puerto 80, y acceso a resolución de nombres DNS, puerto 53:
            </p>
              <pre><code># iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT<br/># iptables -A INPUT -p tcp --dport 53 -j ACCEPT<br/># iptables -A INPUT -p udp --dport 53 -j ACCEPT</code></pre>

            <p>
              Por ejemplo si se quiere denegar todo el tráfico ICMP, evitando que usen la herramienta ping, se utiliza el comando:
            </p>
              <pre><code># /sbin/iptables -A INPUT -p icmp -s <b>IPNUMBER</b> -j DROP</code></pre>

            <p>
              Con esto, se establece una regla que indica que todo lo que provenga de IPNUMBER por el protocolo iCMP, realice un DROP de la conexión, es decir, que no la permita. Con esto la máquina IPNUMBEr no podrá hacer ping.
            </p>

          <h3>Borrado de reglas</h3>
            <p>
              Para borrar las reglas o desactivar el firewall, primero se recomienda poner las políticas a ACCEPT:
            </p>
              <pre><code># iptables -P INPUT ACCEPT<br/># iptables -P OUTPUT ACCEPT</code></pre>

            <p>
              Finalmente, se realiza un vaciado de las reglas:
            </p>
              <pre><code># iptables -F INPUT<br/># iptables -F OUTPUT</code></pre>

            <p>
              Para eliminar una regla específica se utiliza el comando:
            </p>
              <pre><code># iptables -D chain rulenum</code></pre>
            

    </article>
  </div>
</section>


<section class="tutorial-block-intro" style="background-color:#F9F7EB;">
  <div class="container">
    <h2>Reference List</h2>
    <ol>
      <li><cite id="refLinux"> Linux</cite></li>
    </ol>
  </div>
</section>

<footer id="footerSocialMedia">
  <div class="container">
    <div class="row center-block">
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://www.linkedin.com/in/domingoesteban"><img class="footericon" src="../../images/icons/linkedin2-circle-logo-128.png" alt="Linkedin"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://github.com/domingoesteban"><img class="footericon" src="../../images/icons/github2-circle-logo-128.png" alt="Github"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://twitter.com/domingoesteban"><img class="footericon" src="../../images/icons/twitter2-circle-logo-128.png" alt="Twitter"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://google.com/+DomingoEsteban"><img class="footericon" src="../../images/icons/googleplus2-circle-logo-128.png" alt="Google Plus"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.youtube.com/user/domingoestebanc"><img class="footericon" src="../../images/icons/youtube2-circle-logo-128.png" alt="Youtube"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block">
        <a target="_blank" href="https://www.facebook.com/domingoesteban"><img class="footericon" src="../../images/icons/facebook2-circle-logo-128.png" alt="Facebook"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://instagram.com/domingoesteban"><img class="footericon" src="../../images/icons/instagram2-circle-logo-128.png" alt="Instagram"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vine.co/domingoesteban"><img class="footericon" src="../../images/icons/vine-circle-logo-128.png" alt="Vine"/></a>
      </div>
      <div class="col-xs-4 col-sm-1 col-md-offset-1 text-center center-block" >
        <a target="_blank" href="https://vimeo.com/domingoesteban"><img class="footericon" src="../../images/icons/vimeo-circle-logo-128.png" alt="Vimeo"/></a>
      </div>
    </div>
  </div>

  <div class="col-xs-12" id="footerCopyright">
    <h6 class="text-center">Copyright © 2014 Domingo Esteban</h6>
    <!-- <p class="text-center"><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> </p> -->
  </div>

</footer>

<!-- JAVASCRIPT (At the bottom for faster page loading)-->

<!-- jQuery -->
<script src="https://code.jquery.com/jquery.js"></script> <!-- Online version 1 -->
<!--script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script--> <!-- Online version 2 -->

<!-- ARREGLAR!!!! -->
<!--script>window.jQuery || document.write('<script src="includes/js/jquery.js"></script>')</script--> <!-- If no online access 1 -->
<!--script src="includes/js/jquery.js"> </script--> <!-- If no online access 2 -->

<!-- Bootstrap JS -->
<script src="../framework/js/bootstrap.js"> </script>

<!-- Custom JS -->
<script src="../includes/js/scripts.js"></script>

</body>

<!-- PAGINA PARA FORMATO DE REFERENCIAS: http://www.york.ac.uk/integrity/ieee.html -->

</html> 